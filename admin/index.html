<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Admin Dashboard | Mind Core Fitness</title>
    <meta name="robots" content="noindex, nofollow">

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#8B2635">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Mind Core">
    <link rel="apple-touch-icon" href="../Logo.PNG">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../js/dashboard-styles.css">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../Logo.PNG">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-functions-compat.js"></script>
</head>
<body>
    <div class="dashboard-layout">
        <!-- Sidebar -->
        <aside class="dashboard-sidebar" id="sidebar">
            <div class="sidebar-header">
                <img src="../Logo.PNG" alt="Mind Core Fitness">
                <h2>Mind Core Fitness</h2>
            </div>

            <nav class="sidebar-nav">
                <a class="nav-item active" data-section="overview">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                    Overview
                </a>
                <a class="nav-item" data-section="availability">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12,6 12,12 16,14"></polyline>
                    </svg>
                    Availability
                </a>
                <a class="nav-item" data-section="clients">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="9" cy="7" r="4"></circle>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                    </svg>
                    Clients
                </a>
                <a class="nav-item" data-section="calendar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="16" y1="2" x2="16" y2="6"></line>
                        <line x1="8" y1="2" x2="8" y2="6"></line>
                        <line x1="3" y1="10" x2="21" y2="10"></line>
                    </svg>
                    Calendar
                </a>
            </nav>

            <div class="sidebar-footer">
                <div class="user-info">
                    <div class="user-avatar" id="userAvatar">R</div>
                    <div class="user-details">
                        <div class="user-name" id="userName">Ross</div>
                        <div class="user-role">Admin</div>
                    </div>
                </div>
                <button class="logout-btn" id="logoutBtn">Sign Out</button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="dashboard-main">
            <!-- Overview Section -->
            <section class="dashboard-section active" id="section-overview">
                <header class="dashboard-header">
                    <h1>Dashboard Overview</h1>
                </header>

                <div class="dashboard-content">
                    <div class="stats-grid">
                        <div class="stat-card clickable" onclick="showStatsDetail('clients')">
                            <div class="stat-value" id="statClients">0</div>
                            <div class="stat-label">Active Clients</div>
                        </div>
                        <div class="stat-card accent clickable" onclick="showStatsDetail('today')">
                            <div class="stat-value" id="statBookingsToday">0</div>
                            <div class="stat-label">Sessions Today</div>
                        </div>
                        <div class="stat-card clickable" onclick="showStatsDetail('week')">
                            <div class="stat-value" id="statBookingsWeek">0</div>
                            <div class="stat-label">This Week</div>
                        </div>
                        <div class="stat-card clickable" onclick="showStatsDetail('upcoming')">
                            <div class="stat-value" id="statUpcoming">0</div>
                            <div class="stat-label">Upcoming</div>
                        </div>
                    </div>

                    <div class="dashboard-card">
                        <div class="card-header">
                            <h3>Today's Schedule</h3>
                            <span id="todayDate"></span>
                        </div>
                        <div class="card-body">
                            <div class="booking-list" id="todayBookings">
                                <div class="empty-state">
                                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                        <line x1="16" y1="2" x2="16" y2="6"></line>
                                        <line x1="8" y1="2" x2="8" y2="6"></line>
                                        <line x1="3" y1="10" x2="21" y2="10"></line>
                                    </svg>
                                    <h4>No sessions scheduled</h4>
                                    <p>Your day is free!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Availability Section -->
            <section class="dashboard-section" id="section-availability">
                <header class="dashboard-header">
                    <h1>Your Availability</h1>
                    <div class="header-actions">
                        <button class="btn btn-primary" id="saveAvailability" disabled>Save Changes</button>
                    </div>
                </header>

                <div class="dashboard-content">
                    <div class="dashboard-card">
                        <div class="card-header">
                            <h3>Weekly Schedule</h3>
                            <p style="color: var(--text-muted); font-size: 0.9rem;">Click a day to set your available hours</p>
                        </div>
                        <div class="card-body">
                            <div class="availability-grid" id="availabilityGrid">
                                <!-- Days will be generated by JS -->
                            </div>

                            <div id="timeEditor" style="display: none; margin-top: 24px; padding: 20px; background: #f9f9f9; border-radius: 10px;">
                                <h4 style="font-family: 'Montserrat', sans-serif; margin-bottom: 16px;">
                                    Set hours for <span id="selectedDayName"></span>
                                </h4>
                                <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                                    Add multiple time slots for split schedules (e.g., morning and afternoon)
                                </p>

                                <div id="timeSlotsContainer">
                                    <!-- Time slots will be dynamically generated -->
                                </div>

                                <div style="display: flex; gap: 10px; margin-top: 16px; flex-wrap: wrap;">
                                    <button class="btn btn-secondary btn-sm" id="addTimeSlot">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 4px;">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                        Add Time Slot
                                    </button>
                                    <button class="btn btn-success btn-sm" id="applyTime" disabled>Save Day</button>
                                    <button class="btn btn-danger btn-sm" id="removeDay" disabled>Clear Day</button>
                                </div>

                                <!-- Copy to other days -->
                                <div id="copyToOtherDays" style="margin-top: 20px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                                    <p style="font-weight: 500; margin-bottom: 10px; font-size: 0.9rem;">Copy these hours to other days:</p>
                                    <div id="copyDaysCheckboxes" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                                        <!-- Day checkboxes will be generated by JS -->
                                    </div>
                                    <div style="display: flex; gap: 10px;">
                                        <button class="btn btn-secondary btn-sm" id="selectAllDays">Select All Weekdays</button>
                                        <button class="btn btn-primary btn-sm" id="copyHoursBtn" disabled>
                                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 4px;">
                                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                            </svg>
                                            Copy Hours
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="dashboard-card" style="margin-top: 24px;">
                        <div class="card-header">
                            <h3>Block Specific Times</h3>
                        </div>
                        <div class="card-body">
                            <p style="color: var(--text-muted); margin-bottom: 16px;">Block off dates for holidays, appointments, or time off. Click to select a single date or drag to select a range.</p>

                            <div class="block-calendar-container" style="margin-bottom: 20px;">
                                <div class="calendar-header" style="margin-bottom: 12px;">
                                    <button type="button" id="blockCalPrevMonth" class="calendar-nav-btn">&lt;</button>
                                    <h4 id="blockCalendarMonth" style="margin: 0; font-family: 'Montserrat', sans-serif;"></h4>
                                    <button type="button" id="blockCalNextMonth" class="calendar-nav-btn">&gt;</button>
                                </div>
                                <div class="calendar-grid weekdays-only" id="blockCalendarGrid" style="gap: 4px;">
                                    <!-- Calendar will be generated by JS -->
                                </div>
                                <div id="selectedBlockDatesDisplay" style="margin-top: 12px; padding: 10px; background: rgba(153, 49, 60, 0.1); border-radius: 8px; display: none;">
                                    <strong style="color: var(--accent-color);">Selected: </strong>
                                    <span id="selectedBlockDatesText"></span>
                                    <button type="button" id="clearBlockDates" style="margin-left: 10px; background: none; border: none; color: var(--danger); cursor: pointer; font-size: 0.85rem;">Clear</button>
                                </div>
                            </div>

                            <div class="form-row">
                                <div class="form-group" style="margin-bottom: 0; flex: 1;">
                                    <label>Time Range (or check "Block entire day")</label>
                                    <div class="time-input-group" style="margin-top: 0;">
                                        <input type="time" id="blockStartTime" value="09:00">
                                        <span>to</span>
                                        <input type="time" id="blockEndTime" value="17:00">
                                    </div>
                                </div>
                            </div>
                            <div class="form-group" style="margin-top: 16px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="blockAllDay" style="width: auto;">
                                    Block entire day(s)
                                </label>
                            </div>
                            <div class="form-group" style="margin-top: 12px; margin-bottom: 0;">
                                <label>Reason (optional)</label>
                                <input type="text" id="blockReason" placeholder="e.g., Doctor's appointment, Holiday">
                            </div>
                            <button class="btn btn-secondary" style="margin-top: 16px;" id="addBlockedTime">Block Selected Date(s)</button>

                            <div id="blockedTimesList" style="margin-top: 24px;">
                                <!-- Blocked times will be listed here -->
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Clients Section -->
            <section class="dashboard-section" id="section-clients">
                <header class="dashboard-header">
                    <h1>Manage Clients</h1>
                    <div class="header-actions">
                        <button class="btn btn-primary" id="addClientBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            Add Client
                        </button>
                    </div>
                </header>

                <div class="dashboard-content">
                    <div class="dashboard-card">
                        <div class="card-body">
                            <div class="client-list" id="clientList">
                                <div class="empty-state">
                                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                        <circle cx="9" cy="7" r="4"></circle>
                                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                                    </svg>
                                    <h4>No clients yet</h4>
                                    <p>Add your first client to get started</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Calendar Section -->
            <section class="dashboard-section" id="section-calendar">
                <header class="dashboard-header">
                    <h1>Booking Calendar</h1>
                    <div class="header-actions">
                        <button class="btn btn-primary" id="addBookingBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            Add Booking
                        </button>
                    </div>
                </header>

                <div class="dashboard-content">
                    <div class="calendar-container dashboard-card">
                        <div class="calendar-header">
                            <div class="calendar-nav">
                                <button id="prevMonth">&lt;</button>
                            </div>
                            <h3 id="calendarMonth">February 2025</h3>
                            <div class="calendar-nav">
                                <button id="nextMonth">&gt;</button>
                            </div>
                        </div>
                        <div class="calendar-grid weekdays-only" id="calendarGrid">
                            <!-- Calendar will be generated by JS -->
                        </div>
                    </div>

                    <div class="dashboard-card" style="margin-top: 24px;">
                        <div class="card-header">
                            <h3>Selected Day: <span id="selectedDateDisplay">-</span></h3>
                        </div>
                        <div class="card-body">
                            <div class="booking-list" id="selectedDayBookings">
                                <div class="empty-state">
                                    <p>Select a day to see bookings</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <!-- Mobile Sidebar Toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>
    </div>

    <!-- Add Client Modal - Step by Step Wizard -->
    <div class="modal-overlay" id="clientModal">
        <div class="modal booking-wizard-modal client-wizard-modal">
            <div class="modal-header">
                <h3 id="clientModalTitle">Add New Client</h3>
                <button class="modal-close" id="closeClientModal">&times;</button>
            </div>

            <!-- Progress Steps -->
            <div class="wizard-progress client-wizard-progress" id="clientWizardProgress">
                <div class="wizard-step active" data-step="1">
                    <div class="step-number">1</div>
                    <div class="step-label">Name</div>
                </div>
                <div class="wizard-step" data-step="2">
                    <div class="step-number">2</div>
                    <div class="step-label">Email</div>
                </div>
                <div class="wizard-step" data-step="3">
                    <div class="step-number">3</div>
                    <div class="step-label">Duration</div>
                </div>
                <div class="wizard-step" data-step="4">
                    <div class="step-number">4</div>
                    <div class="step-label">Sessions</div>
                </div>
                <div class="wizard-step" data-step="5">
                    <div class="step-number">5</div>
                    <div class="step-label">End Date</div>
                </div>
                <div class="wizard-step" data-step="6">
                    <div class="step-number">6</div>
                    <div class="step-label">Schedule</div>
                </div>
                <div class="wizard-step" data-step="7">
                    <div class="step-number">7</div>
                    <div class="step-label">Confirm</div>
                </div>
            </div>

            <div class="modal-body">
                <form id="clientForm">
                    <!-- Step 1: Name -->
                    <div class="client-wizard-panel active" data-panel="1">
                        <h4>What's the client's name?</h4>
                        <div class="form-group">
                            <label>Full Name *</label>
                            <input type="text" id="clientName" required placeholder="John Smith" class="wizard-input-large">
                        </div>
                    </div>

                    <!-- Step 2: Email -->
                    <div class="client-wizard-panel" data-panel="2">
                        <h4>What's their email address?</h4>
                        <div class="form-group">
                            <label>Email Address *</label>
                            <input type="email" id="clientEmail" required placeholder="john@example.com" class="wizard-input-large">
                        </div>
                        <p style="color: var(--text-muted); font-size: 0.85rem; margin-top: 8px;">They'll receive a password reset email to set up their account.</p>
                    </div>

                    <!-- Step 3: Block Duration (Workout Time) -->
                    <div class="client-wizard-panel" data-panel="3">
                        <h4>How long are their workouts?</h4>
                        <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 16px;">Select the session duration</p>
                        <div class="duration-selection-grid" style="grid-template-columns: repeat(2, 1fr);">
                            <button type="button" class="duration-option client-duration-option selected" data-duration="30">
                                <span class="duration-value">30</span>
                                <span class="duration-unit">minutes</span>
                            </button>
                            <button type="button" class="duration-option client-duration-option" data-duration="45">
                                <span class="duration-value">45</span>
                                <span class="duration-unit">minutes</span>
                            </button>
                        </div>
                        <input type="hidden" id="clientBlockDuration" value="30">
                    </div>

                    <!-- Step 4: Number of Sessions -->
                    <div class="client-wizard-panel" data-panel="4">
                        <h4>How many sessions in their block?</h4>
                        <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 16px;">Total number of sessions included in this training block</p>
                        <div class="form-group">
                            <input type="number" id="clientSessions" min="1" placeholder="e.g. 10" class="wizard-input-large" style="text-align: center; font-size: 2rem; font-weight: 600;">
                        </div>
                        <div class="session-presets">
                            <button type="button" class="session-preset-btn" data-sessions="8">8</button>
                            <button type="button" class="session-preset-btn" data-sessions="10">10</button>
                            <button type="button" class="session-preset-btn" data-sessions="12">12</button>
                            <button type="button" class="session-preset-btn" data-sessions="16">16</button>
                            <button type="button" class="session-preset-btn" data-sessions="20">20</button>
                        </div>
                    </div>

                    <!-- Step 5: Block Dates -->
                    <div class="client-wizard-panel" data-panel="5">
                        <h4>When does their block run?</h4>
                        <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 16px;">Set the start and end dates for this training block</p>
                        <div class="form-row" style="gap: 16px;">
                            <div class="form-group" style="flex: 1;">
                                <label style="text-align: center; display: block; margin-bottom: 8px;">Start Date</label>
                                <input type="date" id="clientBlockStartDate" class="wizard-input-large" style="text-align: center;">
                            </div>
                            <div class="form-group" style="flex: 1;">
                                <label style="text-align: center; display: block; margin-bottom: 8px;">End Date</label>
                                <input type="date" id="clientBlockEndDate" class="wizard-input-large" style="text-align: center;">
                            </div>
                        </div>
                        <div class="date-presets">
                            <button type="button" class="date-preset-btn" data-weeks="4">4 weeks</button>
                            <button type="button" class="date-preset-btn" data-weeks="8">8 weeks</button>
                            <button type="button" class="date-preset-btn" data-weeks="12">12 weeks</button>
                        </div>
                    </div>

                    <!-- Step 6: Pick Days and Times -->
                    <div class="client-wizard-panel" data-panel="6">
                        <h4>Pick their training schedule</h4>
                        <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 12px;">Select 1-3 days for weekly sessions</p>

                        <div class="weekday-selection-grid">
                            <button type="button" class="weekday-btn" data-day="1">Mon</button>
                            <button type="button" class="weekday-btn" data-day="2">Tue</button>
                            <button type="button" class="weekday-btn" data-day="3">Wed</button>
                            <button type="button" class="weekday-btn" data-day="4">Thu</button>
                            <button type="button" class="weekday-btn" data-day="5">Fri</button>
                        </div>

                        <div id="clientDayTimeSelectors" style="margin-top: 20px;">
                            <!-- Time selectors for each selected day will be generated by JS -->
                        </div>
                    </div>

                    <!-- Step 7: Confirm & Create / Edit Mode -->
                    <div class="client-wizard-panel" data-panel="7">
                        <h4 id="clientStep7Title">Review & Create Client</h4>

                        <!-- Read-only summary for new clients -->
                        <div id="clientSummaryReadOnly">
                            <div class="booking-summary">
                                <div class="summary-item">
                                    <span class="summary-label">Name:</span>
                                    <span class="summary-value" id="clientSummaryName">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Email:</span>
                                    <span class="summary-value" id="clientSummaryEmail">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Session Duration:</span>
                                    <span class="summary-value" id="clientSummaryDuration">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Total Sessions:</span>
                                    <span class="summary-value" id="clientSummarySessions">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Block Starts:</span>
                                    <span class="summary-value" id="clientSummaryStartDate">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Block Ends:</span>
                                    <span class="summary-value" id="clientSummaryEndDate">-</span>
                                </div>
                            </div>
                            <div class="booking-summary" id="clientSummarySchedule" style="margin-top: 12px;">
                                <!-- Training schedule will be populated by JS -->
                            </div>
                            <p style="color: var(--text-muted); font-size: 0.85rem; margin-top: 16px;">A password reset email will be sent to the client so they can set up their account.</p>
                        </div>

                        <!-- Editable form for edit mode -->
                        <div id="clientEditForm" style="display: none;">
                            <div class="form-group">
                                <label>Name *</label>
                                <input type="text" id="clientEditName" required placeholder="John Smith">
                            </div>
                            <div class="form-group">
                                <label>Email *</label>
                                <input type="email" id="clientEditEmail" required placeholder="john@example.com">
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Block Duration</label>
                                    <select id="clientEditBlockDuration">
                                        <option value="30">30 minutes</option>
                                        <option value="45">45 minutes</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Number of Sessions</label>
                                    <input type="number" id="clientEditSessions" min="1" placeholder="e.g. 10">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Block Start Date</label>
                                    <input type="date" id="clientEditBlockStartDate">
                                </div>
                                <div class="form-group">
                                    <label>Block End Date</label>
                                    <input type="date" id="clientEditBlockEndDate">
                                </div>
                            </div>
                        </div>
                    </div>

                    <input type="hidden" id="clientId">
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancelClientBtn">Cancel</button>
                <button class="btn btn-secondary" id="clientPrevStepBtn" style="display: none;">Back</button>
                <button class="btn btn-primary" id="clientNextStepBtn">Next</button>
                <button class="btn btn-primary" id="saveClientBtn" style="display: none;">Create Client</button>
            </div>
        </div>
    </div>

    <!-- Add Booking Modal - Step by Step Wizard -->
    <div class="modal-overlay" id="bookingModal">
        <div class="modal booking-wizard-modal">
            <div class="modal-header">
                <h3 id="bookingWizardTitle">Add Booking</h3>
                <button class="modal-close" id="closeBookingModal">&times;</button>
            </div>

            <!-- Progress Steps -->
            <div class="wizard-progress">
                <div class="wizard-step active" data-step="1">
                    <div class="step-number">1</div>
                    <div class="step-label">Client</div>
                </div>
                <div class="wizard-step" data-step="2">
                    <div class="step-number">2</div>
                    <div class="step-label">Duration</div>
                </div>
                <div class="wizard-step" data-step="3">
                    <div class="step-number">3</div>
                    <div class="step-label">Day</div>
                </div>
                <div class="wizard-step" data-step="4">
                    <div class="step-number">4</div>
                    <div class="step-label">Time</div>
                </div>
                <div class="wizard-step" data-step="5">
                    <div class="step-number">5</div>
                    <div class="step-label">Confirm</div>
                </div>
            </div>

            <div class="modal-body">
                <form id="bookingForm">
                    <!-- Step 1: Select Client -->
                    <div class="wizard-panel active" data-panel="1">
                        <h4>Select Client</h4>
                        <div class="client-selection-grid" id="clientSelectionGrid">
                            <!-- Client cards will be populated by JS -->
                        </div>
                        <input type="hidden" id="bookingClient">
                    </div>

                    <!-- Step 2: Select Duration -->
                    <div class="wizard-panel" data-panel="2">
                        <h4>Select Session Duration</h4>
                        <div class="duration-selection-grid">
                            <button type="button" class="duration-option" data-duration="30">
                                <span class="duration-value">30</span>
                                <span class="duration-unit">minutes</span>
                            </button>
                            <button type="button" class="duration-option" data-duration="45">
                                <span class="duration-value">45</span>
                                <span class="duration-unit">minutes</span>
                            </button>
                            <button type="button" class="duration-option selected" data-duration="60">
                                <span class="duration-value">60</span>
                                <span class="duration-unit">minutes</span>
                            </button>
                            <button type="button" class="duration-option" data-duration="90">
                                <span class="duration-value">90</span>
                                <span class="duration-unit">minutes</span>
                            </button>
                        </div>
                        <input type="hidden" id="bookingDuration" value="60">
                    </div>

                    <!-- Step 3: Select Days -->
                    <div class="wizard-panel" data-panel="3">
                        <h4>Select Days</h4>
                        <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 12px;">Select 1-3 days for weekly sessions (e.g., Monday & Wednesday)</p>
                        <div class="booking-calendar-container">
                            <div class="calendar-header">
                                <button type="button" id="bookingPrevMonth">&lt;</button>
                                <h3 id="bookingCalendarMonth">February 2025</h3>
                                <button type="button" id="bookingNextMonth">&gt;</button>
                            </div>
                            <div class="calendar-grid weekdays-only" id="bookingCalendarGrid">
                                <!-- Calendar will be generated by JS -->
                            </div>
                        </div>
                        <p class="selected-days-display" id="selectedDaysDisplay" style="margin-top: 12px; font-weight: 500;"></p>
                        <input type="hidden" id="bookingDate">
                    </div>

                    <!-- Step 4: Select Time for Each Day -->
                    <div class="wizard-panel" data-panel="4">
                        <h4>Select Times</h4>
                        <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 16px;">Choose a time for each day</p>
                        <div id="perDayTimeSelectors">
                            <!-- Time selectors for each day will be generated by JS -->
                        </div>
                    </div>

                    <!-- Step 5: Confirm & Options -->
                    <div class="wizard-panel" data-panel="5">
                        <h4>Confirm Booking</h4>
                        <div class="booking-summary">
                            <div class="summary-item">
                                <span class="summary-label">Client:</span>
                                <span class="summary-value" id="summaryClient">-</span>
                            </div>
                            <div class="summary-item">
                                <span class="summary-label">Duration:</span>
                                <span class="summary-value" id="summaryDuration">-</span>
                            </div>
                            <div class="summary-item" id="sessionsPerWeekItem">
                                <span class="summary-label">Sessions/Week:</span>
                                <span class="summary-value" id="summarySessionsPerWeek">-</span>
                            </div>
                        </div>
                        <div class="booking-summary" id="summarySchedule" style="margin-top: 12px;">
                            <!-- Day/time schedule will be populated by JS -->
                        </div>

                        <div class="repeat-option">
                            <label class="checkbox-container">
                                <input type="checkbox" id="repeatWeekly">
                                <span class="checkmark"></span>
                                <span class="checkbox-label">Repeat weekly until block ends</span>
                            </label>
                            <p class="repeat-info" id="repeatInfo" style="display: none;">
                                This will create <span id="repeatCount">0</span> sessions (<span id="repeatSessionsPerWeek">0</span>/week) until <span id="repeatEndDate">-</span>
                            </p>
                        </div>

                        <div class="form-group" style="margin-top: 16px;">
                            <label>Notes (optional)</label>
                            <textarea id="bookingNotes" rows="2" placeholder="Any notes for this session..."></textarea>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancelBookingBtn">Cancel</button>
                <button class="btn btn-secondary" id="prevStepBtn" style="display: none;">Back</button>
                <button class="btn btn-primary" id="nextStepBtn">Next</button>
                <button class="btn btn-primary" id="saveBookingBtn" style="display: none;">Create Booking</button>
            </div>
        </div>
    </div>

    <!-- Stats Detail Modal -->
    <div class="modal-overlay" id="statsModal">
        <div class="modal stats-detail-modal">
            <div class="modal-header">
                <h3 id="statsModalTitle">Details</h3>
                <button class="modal-close" id="closeStatsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="stats-detail-content" id="statsModalContent">
                    <!-- Content populated dynamically -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="statsModalViewAll">View All</button>
                <button class="btn btn-primary" id="statsModalClose">Close</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script src="../js/firebase-config.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const DAYS_SHORT = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const WEEKDAYS_SHORT = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];

            let currentMonth = new Date();
            let clients = [];

            // Toast notification
            function showToast(message, type = 'success') {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `
                    <span>${message}</span>
                    <button onclick="this.parentElement.remove()">&times;</button>
                `;
                container.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 10);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => toast.remove(), 300);
                }, 4000);
            }

            // Check authentication
            auth.onAuthStateChanged(async (user) => {
                if (!user) {
                    window.location.href = '/dashboard/login.html';
                    return;
                }

                const role = await getUserRole(user.uid);
                if (role !== 'admin') {
                    window.location.href = '/dashboard/index.html';
                    return;
                }

                const userData = await getUserData(user.uid);
                if (userData) {
                    document.getElementById('userName').textContent = userData.name || 'Admin';
                    document.getElementById('userAvatar').textContent = (userData.name || 'A')[0].toUpperCase();
                }

                // Load clients after auth confirmed
                loadClients();
                updateStats();
            });

            // Logout
            document.getElementById('logoutBtn').addEventListener('click', () => logout());

            // Set today's date
            const today = new Date();
            document.getElementById('todayDate').textContent = today.toLocaleDateString('en-GB', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            // ==================
            // CLIENTS
            // ==================
            async function loadClients() {
                try {
                    const snapshot = await db.collection('users').where('role', '==', 'client').get();
                    clients = [];
                    const seenEmails = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        // Deduplicate by email - keep the first one found (usually the older one)
                        if (!seenEmails.has(data.email)) {
                            seenEmails.add(data.email);
                            clients.push({ id: doc.id, ...data });
                        }
                    });
                    renderClientList();
                    updateStats();
                } catch (error) {
                    console.error('Error loading clients:', error);
                    showToast('Failed to load clients', 'error');
                }
            }

            function renderClientList() {
                const container = document.getElementById('clientList');

                if (clients.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                <circle cx="9" cy="7" r="4"></circle>
                            </svg>
                            <h4>No clients yet</h4>
                            <p>Add your first client to get started</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = clients.map(client => `
                    <div class="client-item" data-id="${client.id}">
                        <div class="client-avatar">${(client.name || 'C')[0].toUpperCase()}</div>
                        <div class="client-info">
                            <div class="client-name">${client.name || 'Unknown'}</div>
                            <div class="client-email">${client.email}</div>
                        </div>
                        <div class="client-meta">
                            <span class="client-duration">${client.blockDuration || 60} min</span>
                            ${client.blockStartDate || client.blockEndDate ? `<span class="client-end">${client.blockStartDate ? new Date(client.blockStartDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }) : ''} - ${client.blockEndDate ? new Date(client.blockEndDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }) : ''}</span>` : ''}
                        </div>
                        <div class="client-actions">
                            <button class="btn btn-sm btn-secondary" onclick="editClient('${client.id}')">Edit</button>
                        </div>
                    </div>
                `).join('');
            }

            // ==================
            // CLIENT WIZARD
            // ==================
            let clientWizardState = {
                currentStep: 1,
                isEditMode: false,
                name: '',
                email: '',
                blockDuration: 30,
                totalSessions: 0,
                blockStartDate: '',
                blockEndDate: '',
                selectedDays: [],    // Array of day numbers (1=Mon, 2=Tue, etc.)
                dayTimes: {}         // Object mapping day number to time string
            };

            // Reset client wizard
            function resetClientWizard() {
                clientWizardState = {
                    currentStep: 1,
                    isEditMode: false,
                    name: '',
                    email: '',
                    blockDuration: 30,
                    totalSessions: 0,
                    blockStartDate: '',
                    blockEndDate: '',
                    selectedDays: [],
                    dayTimes: {}
                };
                document.getElementById('clientForm').reset();
                document.getElementById('clientId').value = '';
                document.getElementById('clientBlockDuration').value = '30';

                // Reset duration buttons
                document.querySelectorAll('.client-duration-option').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.duration === '30');
                });

                // Reset weekday buttons
                document.querySelectorAll('.weekday-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Clear day time selectors
                document.getElementById('clientDayTimeSelectors').innerHTML = '';

                // Reset presets
                document.querySelectorAll('.session-preset-btn, .date-preset-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Set default start date to today
                const defaultStart = new Date();
                document.getElementById('clientBlockStartDate').value = defaultStart.toISOString().split('T')[0];
                clientWizardState.blockStartDate = defaultStart.toISOString().split('T')[0];

                // Set default end date to 3 months from now
                const defaultEnd = new Date();
                defaultEnd.setMonth(defaultEnd.getMonth() + 3);
                document.getElementById('clientBlockEndDate').value = defaultEnd.toISOString().split('T')[0];
                clientWizardState.blockEndDate = defaultEnd.toISOString().split('T')[0];

                updateClientWizardUI();
            }

            // Update client wizard UI based on current step
            function updateClientWizardUI() {
                const step = clientWizardState.currentStep;
                const isEditMode = clientWizardState.isEditMode;

                // Update progress steps
                document.querySelectorAll('#clientWizardProgress .wizard-step').forEach((el, i) => {
                    el.classList.remove('active', 'completed');
                    if (i + 1 < step) el.classList.add('completed');
                    if (i + 1 === step) el.classList.add('active');
                });

                // Show/hide panels
                document.querySelectorAll('.client-wizard-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.querySelector(`.client-wizard-panel[data-panel="${step}"]`).classList.add('active');

                // Update buttons
                const prevBtn = document.getElementById('clientPrevStepBtn');
                const nextBtn = document.getElementById('clientNextStepBtn');
                const saveBtn = document.getElementById('saveClientBtn');

                prevBtn.style.display = step > 1 ? 'inline-flex' : 'none';
                nextBtn.style.display = step < 7 ? 'inline-flex' : 'none';
                saveBtn.style.display = step === 7 ? 'inline-flex' : 'none';
                saveBtn.textContent = isEditMode ? 'Update Client' : 'Create Client';

                // Show/hide wizard progress in edit mode (hide schedule step for edit)
                const progressContainer = document.getElementById('clientWizardProgress');
                if (isEditMode) {
                    progressContainer.style.display = 'none';
                } else {
                    progressContainer.style.display = 'flex';
                }

                // Update panel content based on step
                if (step === 6) {
                    renderClientDayTimeSelectors();
                } else if (step === 7) {
                    updateClientSummary();
                }
            }

            // Generate time slots for client scheduling with availability check
            async function generateClientTimeSlotsWithAvailability(dayNum, existingBookings, duration, todayIsSameDay = false) {
                const slots = [];

                // Get trainer's availability for this day of week
                const daySlots = getDaySlots(dayNum);

                // If no availability set for this day, return empty
                if (!daySlots || daySlots.length === 0) {
                    return slots;
                }

                // Calculate minimum allowed time if today is the same day
                let minAllowedMinutes = 0;
                if (todayIsSameDay) {
                    const now = new Date();
                    const currentMinutes = now.getHours() * 60 + now.getMinutes();
                    // Round up to the next 15-minute slot + 15 min buffer
                    minAllowedMinutes = Math.ceil((currentMinutes + 15) / 15) * 15;
                }

                // Generate time slots only within trainer's available windows
                daySlots.forEach(availSlot => {
                    const [startHour, startMin] = availSlot.start.split(':').map(Number);
                    const [endHour, endMin] = availSlot.end.split(':').map(Number);
                    const availStartMinutes = startHour * 60 + startMin;
                    const availEndMinutes = endHour * 60 + endMin;

                    // Generate 15-minute increment slots within this availability window
                    for (let slotStartMinutes = availStartMinutes; slotStartMinutes + duration <= availEndMinutes; slotStartMinutes += 15) {
                        const hour = Math.floor(slotStartMinutes / 60);
                        const min = slotStartMinutes % 60;
                        const time = `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
                        const slotEndMinutes = slotStartMinutes + duration;

                        // Check if this time has already passed today
                        const isPastTime = todayIsSameDay && slotStartMinutes < minAllowedMinutes;

                        // Check if this time slot conflicts with any existing booking
                        const isBooked = existingBookings.some(booking => {
                            const [bHour, bMin] = booking.time.split(':').map(Number);
                            const bookingStart = bHour * 60 + bMin;
                            const bookingDuration = parseInt(booking.duration) || 60;
                            const bookingEnd = bookingStart + bookingDuration;
                            // Check for overlap: slot overlaps if it starts before booking ends AND ends after booking starts
                            return (slotStartMinutes < bookingEnd && slotEndMinutes > bookingStart);
                        });

                        slots.push({ time, isBooked: isBooked || isPastTime, isPastTime });
                    }
                });

                return slots;
            }

            // Get all dates for a specific weekday between today and end date
            function getDatesForWeekday(dayNum, endDate) {
                const dates = [];
                const end = new Date(endDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                let currentDate = new Date(today);

                while (currentDate <= end) {
                    const dayOfWeek = currentDate.getDay();
                    // Convert Sunday=0 to our format (Mon=1, Tue=2, etc.)
                    const ourDayNum = dayOfWeek === 0 ? 7 : dayOfWeek;

                    if (ourDayNum === dayNum) {
                        dates.push(currentDate.toISOString().split('T')[0]);
                    }

                    currentDate.setDate(currentDate.getDate() + 1);
                }

                return dates;
            }

            // Render time selectors for each selected day
            async function renderClientDayTimeSelectors() {
                const container = document.getElementById('clientDayTimeSelectors');
                const days = clientWizardState.selectedDays;
                const dayNames = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const duration = clientWizardState.blockDuration || 30;
                const blockEndDate = clientWizardState.blockEndDate;

                if (days.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-muted); text-align: center;">Select training days above first</p>';
                    return;
                }

                // Show loading state
                container.innerHTML = '<p style="color: var(--text-muted); text-align: center;">Loading available slots...</p>';

                // Fetch existing bookings for all relevant dates
                let allExistingBookings = {};

                if (blockEndDate) {
                    for (const dayNum of days) {
                        const dates = getDatesForWeekday(dayNum, blockEndDate);

                        for (const dateStr of dates) {
                            if (!allExistingBookings[dateStr]) {
                                try {
                                    const snapshot = await db.collection('bookings')
                                        .where('date', '==', dateStr)
                                        .where('status', '==', 'confirmed')
                                        .get();
                                    allExistingBookings[dateStr] = snapshot.docs.map(doc => doc.data());
                                } catch (error) {
                                    try {
                                        const snapshot = await db.collection('bookings')
                                            .where('date', '==', dateStr)
                                            .get();
                                        allExistingBookings[dateStr] = snapshot.docs.map(doc => doc.data()).filter(b => b.status !== 'cancelled');
                                    } catch (err) {
                                        allExistingBookings[dateStr] = [];
                                    }
                                }
                            }
                        }
                    }
                }

                // Build bookings per weekday - aggregate all bookings for each day of week
                const bookingsByWeekday = {};
                for (const dayNum of days) {
                    bookingsByWeekday[dayNum] = [];
                    const dates = blockEndDate ? getDatesForWeekday(dayNum, blockEndDate) : [];
                    for (const dateStr of dates) {
                        if (allExistingBookings[dateStr]) {
                            bookingsByWeekday[dayNum].push(...allExistingBookings[dateStr]);
                        }
                    }
                }

                // Check if today matches any of the selected days
                const todayDate = new Date();
                const todayDayOfWeek = todayDate.getDay();
                const todayOurFormat = todayDayOfWeek === 0 ? 7 : todayDayOfWeek; // Convert to Mon=1...Sun=7 format

                // Generate HTML for each day
                let html = '';
                for (const dayNum of days) {
                    const existingBookings = bookingsByWeekday[dayNum] || [];
                    const todayIsSameDay = todayOurFormat === dayNum;
                    const slots = await generateClientTimeSlotsWithAvailability(dayNum, existingBookings, duration, todayIsSameDay);
                    const selectedTime = clientWizardState.dayTimes[dayNum] || '';

                    html += `
                        <div class="day-time-selector">
                            <div class="day-time-header">
                                <span class="day-time-label">${dayNames[dayNum]}</span>
                                <span class="day-time-selected" id="clientSelectedTime${dayNum}">${selectedTime ? formatTime(selectedTime) : 'Select time'}</span>
                            </div>
                            <div class="day-slots time-slots-container">
                                ${slots.length === 0 ?
                                    '<p style="color: var(--text-muted); text-align: center; padding: 12px; margin: 0;">No availability set for this day</p>' :
                                    slots.map(slot => `
                                        <div class="time-slot ${slot.isBooked ? 'booked' : ''} ${slot.isPastTime ? 'past-time' : ''} ${selectedTime === slot.time ? 'selected' : ''}"
                                             data-day="${dayNum}" data-time="${slot.time}"
                                             ${slot.isPastTime ? 'title="This time has already passed"' : (slot.isBooked ? 'title="This time is already booked"' : '')}>
                                            ${formatTime(slot.time)}
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html;

                // Add click handlers for time slots (excluding booked ones)
                container.querySelectorAll('.time-slot:not(.booked)').forEach(slot => {
                    slot.addEventListener('click', function() {
                        const day = parseInt(this.dataset.day);
                        const time = this.dataset.time;

                        // Update state
                        clientWizardState.dayTimes[day] = time;

                        // Update UI - remove selected from siblings, add to this
                        this.closest('.day-time-selector').querySelectorAll('.time-slot').forEach(s => {
                            s.classList.remove('selected');
                        });
                        this.classList.add('selected');

                        // Update the selected time display
                        document.getElementById(`clientSelectedTime${day}`).textContent = formatTime(time);
                    });
                });
            }

            // Format time for display
            function formatTime(time) {
                const [hours, minutes] = time.split(':');
                const h = parseInt(hours);
                const ampm = h >= 12 ? 'PM' : 'AM';
                const h12 = h % 12 || 12;
                return `${h12}:${minutes} ${ampm}`;
            }

            // Update client summary panel
            function updateClientSummary() {
                const state = clientWizardState;
                const dayNames = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

                // Toggle between read-only and edit form
                const readOnlyContainer = document.getElementById('clientSummaryReadOnly');
                const editFormContainer = document.getElementById('clientEditForm');
                const step7Title = document.getElementById('clientStep7Title');

                if (state.isEditMode) {
                    // Show edit form, hide read-only
                    readOnlyContainer.style.display = 'none';
                    editFormContainer.style.display = 'block';
                    step7Title.textContent = 'Edit Client';

                    // Populate edit form fields
                    document.getElementById('clientEditName').value = state.name || '';
                    document.getElementById('clientEditEmail').value = state.email || '';
                    document.getElementById('clientEditBlockDuration').value = state.blockDuration || 30;
                    document.getElementById('clientEditSessions').value = state.totalSessions || '';
                    document.getElementById('clientEditBlockStartDate').value = state.blockStartDate || '';
                    document.getElementById('clientEditBlockEndDate').value = state.blockEndDate || '';
                } else {
                    // Show read-only summary, hide edit form
                    readOnlyContainer.style.display = 'block';
                    editFormContainer.style.display = 'none';
                    step7Title.textContent = 'Review & Create Client';

                    document.getElementById('clientSummaryName').textContent = state.name || '-';
                    document.getElementById('clientSummaryEmail').textContent = state.email || '-';
                    document.getElementById('clientSummaryDuration').textContent = state.blockDuration + ' minutes';
                    document.getElementById('clientSummarySessions').textContent = state.totalSessions || '-';

                    if (state.blockStartDate) {
                        const startDate = new Date(state.blockStartDate);
                        document.getElementById('clientSummaryStartDate').textContent = startDate.toLocaleDateString('en-GB', {
                            weekday: 'long',
                            day: 'numeric',
                            month: 'long',
                            year: 'numeric'
                        });
                    } else {
                        document.getElementById('clientSummaryStartDate').textContent = '-';
                    }

                    if (state.blockEndDate) {
                        const endDate = new Date(state.blockEndDate);
                        document.getElementById('clientSummaryEndDate').textContent = endDate.toLocaleDateString('en-GB', {
                            weekday: 'long',
                            day: 'numeric',
                            month: 'long',
                            year: 'numeric'
                        });
                    } else {
                        document.getElementById('clientSummaryEndDate').textContent = '-';
                    }

                    // Schedule summary
                    const scheduleContainer = document.getElementById('clientSummarySchedule');
                    if (state.selectedDays.length > 0) {
                        const scheduleHtml = state.selectedDays.map(dayNum => {
                            const time = state.dayTimes[dayNum];
                            return `
                                <div class="summary-item">
                                    <span class="summary-label">${dayNames[dayNum]}:</span>
                                    <span class="summary-value">${time ? formatTime(time) : 'No time selected'}</span>
                                </div>
                            `;
                        }).join('');
                        scheduleContainer.innerHTML = scheduleHtml;
                        scheduleContainer.style.display = 'block';
                    } else {
                        scheduleContainer.style.display = 'none';
                    }
                }
            }

            // Add Client Modal - Open Wizard
            document.getElementById('addClientBtn').addEventListener('click', () => {
                document.getElementById('clientModalTitle').textContent = 'Add New Client';
                resetClientWizard();
                document.getElementById('clientModal').classList.add('show');
            });

            // Duration option click handlers
            document.querySelectorAll('.client-duration-option').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.client-duration-option').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    clientWizardState.blockDuration = parseInt(this.dataset.duration);
                    document.getElementById('clientBlockDuration').value = this.dataset.duration;
                });
            });

            // Session preset click handlers
            document.querySelectorAll('.session-preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.session-preset-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    const sessions = parseInt(this.dataset.sessions);
                    clientWizardState.totalSessions = sessions;
                    document.getElementById('clientSessions').value = sessions;
                });
            });

            // Date preset click handlers
            document.querySelectorAll('.date-preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.date-preset-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    const weeks = parseInt(this.dataset.weeks);

                    // Set start date to today
                    const startDate = new Date();
                    const startStr = startDate.toISOString().split('T')[0];
                    clientWizardState.blockStartDate = startStr;
                    document.getElementById('clientBlockStartDate').value = startStr;

                    // Set end date to X weeks from today
                    const endDate = new Date();
                    endDate.setDate(endDate.getDate() + (weeks * 7));
                    const endStr = endDate.toISOString().split('T')[0];
                    clientWizardState.blockEndDate = endStr;
                    document.getElementById('clientBlockEndDate').value = endStr;
                });
            });

            // Weekday button click handlers
            document.querySelectorAll('.weekday-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const day = parseInt(this.dataset.day);
                    const isSelected = this.classList.contains('selected');

                    if (isSelected) {
                        // Remove from selection
                        this.classList.remove('selected');
                        clientWizardState.selectedDays = clientWizardState.selectedDays.filter(d => d !== day);
                        delete clientWizardState.dayTimes[day];
                    } else if (clientWizardState.selectedDays.length < 3) {
                        // Add to selection (max 3)
                        this.classList.add('selected');
                        clientWizardState.selectedDays.push(day);
                        clientWizardState.selectedDays.sort((a, b) => a - b);
                    } else {
                        showToast('Maximum 3 training days allowed', 'warning');
                    }

                    // Re-render time selectors
                    renderClientDayTimeSelectors();
                });
            });

            // Client wizard navigation - Next
            document.getElementById('clientNextStepBtn').addEventListener('click', () => {
                const step = clientWizardState.currentStep;

                // Validation for each step
                if (step === 1) {
                    const name = document.getElementById('clientName').value.trim();
                    if (!name) {
                        showToast('Please enter a name', 'error');
                        return;
                    }
                    clientWizardState.name = name;
                }
                if (step === 2) {
                    const email = document.getElementById('clientEmail').value.trim();
                    if (!email) {
                        showToast('Please enter an email address', 'error');
                        return;
                    }
                    // Basic email validation
                    if (!email.includes('@') || !email.includes('.')) {
                        showToast('Please enter a valid email address', 'error');
                        return;
                    }
                    clientWizardState.email = email;
                }
                if (step === 3) {
                    // Duration is already set via button clicks
                }
                if (step === 4) {
                    const sessions = parseInt(document.getElementById('clientSessions').value);
                    if (!sessions || sessions < 1) {
                        showToast('Please enter number of sessions', 'error');
                        return;
                    }
                    clientWizardState.totalSessions = sessions;
                }
                if (step === 5) {
                    const startDate = document.getElementById('clientBlockStartDate').value;
                    const endDate = document.getElementById('clientBlockEndDate').value;
                    if (!startDate) {
                        showToast('Please select a block start date', 'error');
                        return;
                    }
                    if (!endDate) {
                        showToast('Please select a block end date', 'error');
                        return;
                    }
                    if (startDate > endDate) {
                        showToast('Start date must be before end date', 'error');
                        return;
                    }
                    clientWizardState.blockStartDate = startDate;
                    clientWizardState.blockEndDate = endDate;
                }
                if (step === 6) {
                    if (clientWizardState.selectedDays.length === 0) {
                        showToast('Please select at least one training day', 'error');
                        return;
                    }
                    // Check all selected days have times
                    const missingTimes = clientWizardState.selectedDays.filter(d => !clientWizardState.dayTimes[d]);
                    if (missingTimes.length > 0) {
                        showToast('Please select a time for each training day', 'error');
                        return;
                    }
                }

                if (step < 7) {
                    clientWizardState.currentStep++;
                    updateClientWizardUI();
                }
            });

            // Client wizard navigation - Previous
            document.getElementById('clientPrevStepBtn').addEventListener('click', () => {
                if (clientWizardState.currentStep > 1) {
                    clientWizardState.currentStep--;
                    updateClientWizardUI();
                }
            });

            // Save Client
            document.getElementById('saveClientBtn').addEventListener('click', async () => {
                const state = clientWizardState;
                let name, email, blockDuration, blockStartDate, blockEndDate, totalSessions;

                if (state.isEditMode) {
                    // Read from edit form
                    name = document.getElementById('clientEditName').value.trim();
                    email = document.getElementById('clientEditEmail').value.trim();
                    blockDuration = parseInt(document.getElementById('clientEditBlockDuration').value);
                    blockStartDate = document.getElementById('clientEditBlockStartDate').value;
                    blockEndDate = document.getElementById('clientEditBlockEndDate').value;
                    totalSessions = parseInt(document.getElementById('clientEditSessions').value) || 0;
                } else {
                    // Read from wizard state
                    name = state.name || document.getElementById('clientName').value.trim();
                    email = state.email || document.getElementById('clientEmail').value.trim();
                    blockDuration = state.blockDuration || parseInt(document.getElementById('clientBlockDuration').value);
                    blockStartDate = state.blockStartDate || document.getElementById('clientBlockStartDate').value;
                    blockEndDate = state.blockEndDate || document.getElementById('clientBlockEndDate').value;
                    totalSessions = state.totalSessions || parseInt(document.getElementById('clientSessions').value) || 0;
                }

                const clientId = document.getElementById('clientId').value;

                if (!name || !email) {
                    showToast('Please fill in name and email', 'error');
                    return;
                }

                const saveBtn = document.getElementById('saveClientBtn');
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';

                try {
                    let newClientId = clientId;

                    if (clientId) {
                        // Update existing client
                        await db.collection('users').doc(clientId).update({
                            name,
                            email,
                            blockDuration,
                            blockStartDate,
                            blockEndDate,
                            totalSessions,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        showToast('Client updated successfully');
                    } else {
                        // Check if a client with this email already exists
                        const existingClients = await db.collection('users')
                            .where('email', '==', email)
                            .where('role', '==', 'client')
                            .get();

                        if (!existingClients.empty) {
                            showToast('A client with this email already exists', 'error');
                            saveBtn.disabled = false;
                            saveBtn.textContent = 'Create Client';
                            return;
                        }

                        // Try Cloud Function first (creates Auth user + Firestore doc)
                        let cloudFunctionWorked = false;

                        try {
                            const functions = firebase.functions();
                            const createClientFn = functions.httpsCallable('createClient');

                            const result = await createClientFn({
                                name,
                                email,
                                blockDuration,
                                blockStartDate,
                                blockEndDate,
                                totalSessions
                            });

                            if (result.data.success) {
                                cloudFunctionWorked = true;
                                newClientId = result.data.uid;
                                showToast(`Client created! Password reset email sent to ${email}`);
                            }
                        } catch (cfError) {
                            console.log('Cloud Function not available, using fallback:', cfError.message);
                        }

                        // Fallback: Create Firestore document only if Cloud Function failed
                        if (!cloudFunctionWorked) {
                            // Create user document in Firestore
                            const newUserRef = db.collection('users').doc();
                            await newUserRef.set({
                                name,
                                email,
                                role: 'client',
                                blockDuration,
                                blockStartDate,
                                blockEndDate,
                                totalSessions,
                                sessionsUsed: 0,
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                needsPasswordSetup: true,
                                onboardingComplete: false
                            });
                            newClientId = newUserRef.id;
                            showToast(`Client added to database. Note: Deploy Cloud Functions to enable automatic login setup.`, 'warning');
                        }

                        // Create initial bookings based on schedule (only for new clients)
                        if (state.selectedDays.length > 0 && Object.keys(state.dayTimes).length > 0) {
                            await createInitialBookings(newClientId, name, email, state);
                        }
                    }

                    document.getElementById('clientModal').classList.remove('show');
                    loadClients();
                } catch (error) {
                    console.error('Error saving client:', error);
                    showToast('Failed to save client: ' + error.message, 'error');
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = state.isEditMode ? 'Update Client' : 'Create Client';
                }
            });

            // Create initial bookings for new client based on schedule
            async function createInitialBookings(clientId, clientName, clientEmail, state) {
                const { selectedDays, dayTimes, blockDuration, blockStartDate, blockEndDate, totalSessions } = state;
                const endDate = new Date(blockEndDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // Use blockStartDate if provided and it's in the future, otherwise use today
                let startDate = today;
                if (blockStartDate) {
                    const providedStart = new Date(blockStartDate);
                    providedStart.setHours(0, 0, 0, 0);
                    if (providedStart >= today) {
                        startDate = providedStart;
                    }
                }

                let bookingsCreated = 0;
                const maxBookings = totalSessions || 999;
                const batch = db.batch();

                // Loop through weeks until end date
                let currentDate = new Date(startDate);

                while (currentDate <= endDate && bookingsCreated < maxBookings) {
                    const dayOfWeek = currentDate.getDay();
                    // Convert Sunday=0 to our format (Mon=1, Tue=2, etc.)
                    const ourDayNum = dayOfWeek === 0 ? 7 : dayOfWeek;

                    if (selectedDays.includes(ourDayNum) && dayTimes[ourDayNum]) {
                        const dateStr = currentDate.toISOString().split('T')[0];
                        const time = dayTimes[ourDayNum];

                        // Calculate end time
                        const [startHour, startMin] = time.split(':').map(Number);
                        const endMinutes = startHour * 60 + startMin + blockDuration;
                        const endHour = Math.floor(endMinutes / 60);
                        const endMin = endMinutes % 60;
                        const endTime = `${endHour.toString().padStart(2, '0')}:${endMin.toString().padStart(2, '0')}`;

                        const bookingRef = db.collection('bookings').doc();
                        batch.set(bookingRef, {
                            clientId,
                            clientName,
                            clientEmail,
                            date: dateStr,
                            time,
                            endTime,
                            duration: blockDuration,
                            status: 'confirmed',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });

                        bookingsCreated++;
                    }

                    // Move to next day
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                if (bookingsCreated > 0) {
                    await batch.commit();
                    showToast(`Created ${bookingsCreated} scheduled sessions`, 'success');
                }
            }

            // Edit client function (global) - simplified for editing
            window.editClient = async (id) => {
                const client = clients.find(c => c.id === id);
                if (!client) return;

                // Reset and set edit mode
                resetClientWizard();
                clientWizardState.isEditMode = true;
                clientWizardState.currentStep = 7; // Go straight to summary/confirm step

                document.getElementById('clientModalTitle').textContent = 'Edit Client';
                document.getElementById('clientId').value = id;
                document.getElementById('clientName').value = client.name || '';
                document.getElementById('clientEmail').value = client.email || '';
                document.getElementById('clientBlockDuration').value = client.blockDuration || 30;
                document.getElementById('clientBlockStartDate').value = client.blockStartDate || '';
                document.getElementById('clientBlockEndDate').value = client.blockEndDate || '';
                document.getElementById('clientSessions').value = client.totalSessions || '';

                // Update wizard state
                clientWizardState.name = client.name || '';
                clientWizardState.email = client.email || '';
                clientWizardState.blockDuration = client.blockDuration || 30;
                clientWizardState.blockStartDate = client.blockStartDate || '';
                clientWizardState.blockEndDate = client.blockEndDate || '';
                clientWizardState.totalSessions = client.totalSessions || 0;

                // Update duration buttons
                document.querySelectorAll('.client-duration-option').forEach(btn => {
                    btn.classList.toggle('selected', parseInt(btn.dataset.duration) === clientWizardState.blockDuration);
                });

                updateClientWizardUI();
                document.getElementById('clientModal').classList.add('show');
            };

            // Update stats
            async function updateStats() {
                document.getElementById('statClients').textContent = clients.length;

                // Get today's bookings
                const todayStr = today.toISOString().split('T')[0];
                try {
                    const bookingsToday = await db.collection('bookings')
                        .where('date', '==', todayStr)
                        .get();
                    const confirmedToday = bookingsToday.docs.filter(doc => doc.data().status === 'confirmed').length;
                    document.getElementById('statBookingsToday').textContent = confirmedToday;

                    // Get this week's bookings
                    const weekStart = new Date(today);
                    weekStart.setDate(today.getDate() - today.getDay());
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekStart.getDate() + 6);

                    const bookingsWeek = await db.collection('bookings')
                        .where('date', '>=', weekStart.toISOString().split('T')[0])
                        .where('date', '<=', weekEnd.toISOString().split('T')[0])
                        .get();
                    const confirmedWeek = bookingsWeek.docs.filter(doc => doc.data().status === 'confirmed').length;
                    document.getElementById('statBookingsWeek').textContent = confirmedWeek;

                    // Get all upcoming bookings
                    const upcoming = await db.collection('bookings')
                        .where('date', '>=', todayStr)
                        .get();
                    const confirmedUpcoming = upcoming.docs.filter(doc => doc.data().status === 'confirmed').length;
                    document.getElementById('statUpcoming').textContent = confirmedUpcoming;
                } catch (error) {
                    console.error('Error loading stats:', error);
                }
            }

            // ==================
            // NAVIGATION
            // ==================
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function() {
                    const section = this.dataset.section;
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                    document.querySelectorAll('.dashboard-section').forEach(s => s.classList.remove('active'));
                    document.getElementById('section-' + section).classList.add('active');
                    document.getElementById('sidebar').classList.remove('open');

                    if (section === 'calendar') renderCalendar();
                    else if (section === 'availability') renderAvailabilityGrid();
                    else if (section === 'clients') loadClients();
                });
            });

            document.getElementById('sidebarToggle').addEventListener('click', function() {
                document.getElementById('sidebar').classList.toggle('open');
            });

            // Navigate to section from stat cards
            function navigateToSection(section) {
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                document.querySelector(`.nav-item[data-section="${section}"]`).classList.add('active');
                document.querySelectorAll('.dashboard-section').forEach(s => s.classList.remove('active'));
                document.getElementById('section-' + section).classList.add('active');

                if (section === 'calendar') renderCalendar();
                else if (section === 'availability') renderAvailabilityGrid();
                else if (section === 'clients') loadClients();
            }

            // Show stats detail popup when clicking dashboard cards
            let currentStatsType = null;

            window.showStatsDetail = async function(type) {
                currentStatsType = type;
                const modal = document.getElementById('statsModal');
                const title = document.getElementById('statsModalTitle');
                const content = document.getElementById('statsModalContent');
                const viewAllBtn = document.getElementById('statsModalViewAll');

                content.innerHTML = '<div class="loading-spinner">Loading...</div>';

                const today = new Date();
                today.setHours(0, 0, 0, 0);

                const endOfWeek = new Date(today);
                endOfWeek.setDate(today.getDate() + (7 - today.getDay()));
                endOfWeek.setHours(23, 59, 59, 999);

                try {
                    if (type === 'clients') {
                        title.textContent = 'Active Clients';
                        viewAllBtn.textContent = 'View All Clients';
                        viewAllBtn.onclick = () => {
                            modal.classList.remove('show');
                            navigateToSection('clients');
                        };

                        if (clients.length === 0) {
                            content.innerHTML = '<p class="no-data">No active clients</p>';
                        } else {
                            content.innerHTML = clients.slice(0, 5).map(client => `
                                <div class="stats-detail-item">
                                    <div class="stats-detail-avatar">${client.name.charAt(0).toUpperCase()}</div>
                                    <div class="stats-detail-info">
                                        <div class="stats-detail-name">${client.name}</div>
                                        <div class="stats-detail-sub">${(client.totalSessions || 0) - (client.sessionsUsed || 0)} sessions remaining</div>
                                    </div>
                                </div>
                            `).join('');
                            if (clients.length > 5) {
                                content.innerHTML += `<p class="stats-detail-more">+${clients.length - 5} more clients</p>`;
                            }
                        }
                    } else if (type === 'today') {
                        title.textContent = "Today's Sessions";
                        viewAllBtn.textContent = 'View Calendar';
                        viewAllBtn.onclick = () => {
                            modal.classList.remove('show');
                            navigateToSection('calendar');
                        };

                        const todayStr = today.toISOString().split('T')[0];
                        const snapshot = await db.collection('bookings')
                            .where('date', '==', todayStr)
                            .get();

                        const bookings = snapshot.docs
                            .map(doc => ({ id: doc.id, ...doc.data() }))
                            .filter(b => b.status === 'confirmed')
                            .sort((a, b) => (a.time || a.startTime || '').localeCompare(b.time || b.startTime || ''));

                        if (bookings.length === 0) {
                            content.innerHTML = '<p class="no-data">No sessions scheduled for today</p>';
                        } else {
                            content.innerHTML = bookings.map(booking => `
                                <div class="stats-detail-item">
                                    <div class="stats-detail-time">${formatTimeDisplay(booking.time || booking.startTime)}</div>
                                    <div class="stats-detail-info">
                                        <div class="stats-detail-name">${booking.clientName}</div>
                                        <div class="stats-detail-sub">${booking.duration || 30} min session</div>
                                    </div>
                                </div>
                            `).join('');
                        }
                    } else if (type === 'week') {
                        title.textContent = 'Sessions This Week';
                        viewAllBtn.textContent = 'View Calendar';
                        viewAllBtn.onclick = () => {
                            modal.classList.remove('show');
                            navigateToSection('calendar');
                        };

                        const todayStr = today.toISOString().split('T')[0];
                        const endWeekStr = endOfWeek.toISOString().split('T')[0];
                        const snapshot = await db.collection('bookings')
                            .where('date', '>=', todayStr)
                            .where('date', '<=', endWeekStr)
                            .get();

                        const bookings = snapshot.docs
                            .map(doc => ({ id: doc.id, ...doc.data() }))
                            .filter(b => b.status === 'confirmed')
                            .sort((a, b) => (a.date + (a.time || a.startTime || '')).localeCompare(b.date + (b.time || b.startTime || '')));

                        if (bookings.length === 0) {
                            content.innerHTML = '<p class="no-data">No sessions scheduled this week</p>';
                        } else {
                            const grouped = {};
                            bookings.forEach(b => {
                                if (!grouped[b.date]) grouped[b.date] = [];
                                grouped[b.date].push(b);
                            });

                            let html = '';
                            Object.keys(grouped).sort().slice(0, 4).forEach(date => {
                                const dateObj = new Date(date + 'T00:00:00');
                                const dayName = DAYS_SHORT[dateObj.getDay()];
                                const dayNum = dateObj.getDate();
                                html += `<div class="stats-detail-date-header">${dayName} ${dayNum}</div>`;
                                grouped[date].slice(0, 3).forEach(booking => {
                                    html += `
                                        <div class="stats-detail-item compact">
                                            <div class="stats-detail-time">${formatTimeDisplay(booking.time || booking.startTime)}</div>
                                            <div class="stats-detail-info">
                                                <div class="stats-detail-name">${booking.clientName}</div>
                                            </div>
                                        </div>
                                    `;
                                });
                                if (grouped[date].length > 3) {
                                    html += `<p class="stats-detail-more">+${grouped[date].length - 3} more</p>`;
                                }
                            });
                            content.innerHTML = html;
                        }
                    } else if (type === 'upcoming') {
                        title.textContent = 'Upcoming Sessions';
                        viewAllBtn.textContent = 'View Calendar';
                        viewAllBtn.onclick = () => {
                            modal.classList.remove('show');
                            navigateToSection('calendar');
                        };

                        // Get bookings for next 4 weeks
                        const todayStr = today.toISOString().split('T')[0];
                        const fourWeeksLater = new Date(today);
                        fourWeeksLater.setDate(today.getDate() + 28);
                        const fourWeeksStr = fourWeeksLater.toISOString().split('T')[0];

                        const snapshot = await db.collection('bookings')
                            .where('date', '>=', todayStr)
                            .where('date', '<=', fourWeeksStr)
                            .get();

                        const bookings = snapshot.docs
                            .map(doc => ({ id: doc.id, ...doc.data() }))
                            .filter(b => b.status === 'confirmed')
                            .sort((a, b) => (a.date + (a.time || a.startTime || '')).localeCompare(b.date + (b.time || b.startTime || '')));

                        if (bookings.length === 0) {
                            content.innerHTML = '<p class="no-data">No upcoming sessions</p>';
                        } else {
                            // Group by week
                            const getWeekNumber = (dateStr) => {
                                const date = new Date(dateStr + 'T00:00:00');
                                const diffDays = Math.floor((date - today) / (1000 * 60 * 60 * 24));
                                return Math.floor(diffDays / 7);
                            };

                            const weekNames = ['This Week', 'Next Week', 'Week 3', 'Week 4'];
                            const weeks = {};

                            bookings.forEach(b => {
                                const weekNum = getWeekNumber(b.date);
                                if (weekNum >= 0 && weekNum < 4) {
                                    if (!weeks[weekNum]) weeks[weekNum] = {};
                                    if (!weeks[weekNum][b.date]) weeks[weekNum][b.date] = [];
                                    weeks[weekNum][b.date].push(b);
                                }
                            });

                            let html = '';
                            Object.keys(weeks).sort((a, b) => a - b).forEach(weekNum => {
                                html += `<div class="stats-detail-week-header">${weekNames[weekNum]}</div>`;
                                Object.keys(weeks[weekNum]).sort().forEach(date => {
                                    const dateObj = new Date(date + 'T00:00:00');
                                    const dayName = DAYS_SHORT[dateObj.getDay()];
                                    const dayNum = dateObj.getDate();
                                    html += `<div class="stats-detail-date-header">${dayName} ${dayNum}</div>`;
                                    weeks[weekNum][date].forEach(booking => {
                                        html += `
                                            <div class="stats-detail-item compact">
                                                <div class="stats-detail-time">${formatTimeDisplay(booking.time || booking.startTime)}</div>
                                                <div class="stats-detail-info">
                                                    <div class="stats-detail-name">${booking.clientName}</div>
                                                </div>
                                            </div>
                                        `;
                                    });
                                });
                            });
                            content.innerHTML = html;
                        }
                    }
                } catch (error) {
                    console.error('Error loading stats detail:', error);
                    content.innerHTML = `<p class="no-data">Error: ${error.message || 'Unknown error'}</p>`;
                }

                modal.classList.add('show');
            }

            // Stats modal close handlers
            document.getElementById('closeStatsModal').addEventListener('click', () => {
                document.getElementById('statsModal').classList.remove('show');
            });
            document.getElementById('statsModalClose').addEventListener('click', () => {
                document.getElementById('statsModal').classList.remove('show');
            });
            document.getElementById('statsModal').addEventListener('click', (e) => {
                if (e.target.id === 'statsModal') {
                    document.getElementById('statsModal').classList.remove('show');
                }
            });

            // ==================
            // AVAILABILITY
            // ==================
            // New format: { 0: { slots: [{start: '06:00', end: '12:15'}, {start: '14:00', end: '18:00'}] }, ... }
            // Backward compatible with old format: { 0: {start: '09:00', end: '17:00'}, ... }
            let availability = {};
            let originalAvailability = {}; // To track changes
            let selectedDay = null;
            let currentSlots = []; // Temp storage for editing slots

            // Format time to 12-hour display
            function formatTimeDisplay(time24) {
                if (!time24) return 'TBD';
                const [hours, minutes] = time24.split(':').map(Number);
                const period = hours >= 12 ? 'PM' : 'AM';
                const hours12 = hours % 12 || 12;
                return `${hours12}:${minutes.toString().padStart(2, '0')} ${period}`;
            }

            // Migrate old format to new format (backward compatibility)
            function migrateAvailabilityFormat(data) {
                const migrated = {};
                for (const day in data) {
                    const dayData = data[day];
                    if (dayData.slots) {
                        // Already new format
                        migrated[day] = dayData;
                    } else if (dayData.start && dayData.end) {
                        // Old format - convert to new
                        migrated[day] = { slots: [{ start: dayData.start, end: dayData.end }] };
                    }
                }
                return migrated;
            }

            // Get slots for a day (handles both formats)
            function getDaySlots(dayIndex) {
                const dayData = availability[dayIndex];
                if (!dayData) return [];
                if (dayData.slots) return dayData.slots;
                if (dayData.start && dayData.end) return [{ start: dayData.start, end: dayData.end }];
                return [];
            }

            function renderAvailabilityGrid() {
                const grid = document.getElementById('availabilityGrid');
                grid.innerHTML = DAYS.map((day, i) => {
                    const slots = getDaySlots(i);
                    const hasTime = slots.length > 0;
                    let timeText = 'Not set';
                    if (hasTime) {
                        timeText = slots.map(slot =>
                            `${formatTimeDisplay(slot.start)} - ${formatTimeDisplay(slot.end)}`
                        ).join('<br>');
                    }
                    const activeClass = hasTime ? 'active' : '';
                    const selectedClass = selectedDay === i ? 'selected' : '';

                    return `
                        <div class="day-card ${activeClass} ${selectedClass}" data-day="${i}">
                            <div class="day-name">${DAYS_SHORT[i]}</div>
                            <div class="day-times">${timeText}</div>
                        </div>
                    `;
                }).join('');

                // Add click handlers to day cards
                grid.querySelectorAll('.day-card').forEach(card => {
                    card.addEventListener('click', function() {
                        const dayIndex = parseInt(this.dataset.day);
                        selectDay(dayIndex);
                    });
                });
            }

            function renderTimeSlots() {
                const container = document.getElementById('timeSlotsContainer');
                if (currentSlots.length === 0) {
                    currentSlots = [{ start: '09:00', end: '17:00' }];
                }

                container.innerHTML = currentSlots.map((slot, index) => `
                    <div class="time-slot-row" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding: 12px; background: white; border-radius: 8px; border: 1px solid #e0e0e0;">
                        <span style="font-weight: 500; min-width: 60px; color: var(--text-muted);">Slot ${index + 1}</span>
                        <input type="time" class="slot-start" data-index="${index}" value="${slot.start}" style="padding: 8px;">
                        <span>to</span>
                        <input type="time" class="slot-end" data-index="${index}" value="${slot.end}" style="padding: 8px;">
                        ${currentSlots.length > 1 ? `
                            <button class="btn btn-danger btn-sm remove-slot" data-index="${index}" style="padding: 6px 10px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        ` : ''}
                    </div>
                `).join('');

                // Add event listeners for input changes
                container.querySelectorAll('.slot-start').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        currentSlots[index].start = this.value;
                    });
                });

                container.querySelectorAll('.slot-end').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        currentSlots[index].end = this.value;
                    });
                });

                // Add remove slot handlers
                container.querySelectorAll('.remove-slot').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const index = parseInt(this.dataset.index);
                        currentSlots.splice(index, 1);
                        renderTimeSlots();
                    });
                });
            }

            function selectDay(dayIndex) {
                selectedDay = dayIndex;
                const timeEditor = document.getElementById('timeEditor');

                // Update selected day name
                document.getElementById('selectedDayName').textContent = DAYS[dayIndex];

                // Load existing slots or create default
                currentSlots = [...getDaySlots(dayIndex)];
                if (currentSlots.length === 0) {
                    currentSlots = [{ start: '09:00', end: '17:00' }];
                } else {
                    // Deep copy to avoid reference issues
                    currentSlots = currentSlots.map(s => ({ ...s }));
                }

                // Render time slots
                renderTimeSlots();

                // Render copy to other days checkboxes
                renderCopyDaysCheckboxes();

                // Enable buttons
                document.getElementById('applyTime').disabled = false;
                document.getElementById('removeDay').disabled = getDaySlots(dayIndex).length === 0;

                // Show time editor
                timeEditor.style.display = 'block';

                // Re-render to show selection
                renderAvailabilityGrid();
            }

            // Add new time slot
            document.getElementById('addTimeSlot').addEventListener('click', function() {
                if (selectedDay === null) return;

                // Default new slot starts after the last slot ends
                let newStart = '14:00';
                let newEnd = '18:00';

                if (currentSlots.length > 0) {
                    const lastSlot = currentSlots[currentSlots.length - 1];
                    // Try to start 1 hour after the last slot ends
                    const [hours, minutes] = lastSlot.end.split(':').map(Number);
                    const newStartHours = Math.min(hours + 1, 23);
                    newStart = `${newStartHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                    const newEndHours = Math.min(newStartHours + 4, 23);
                    newEnd = `${newEndHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                }

                currentSlots.push({ start: newStart, end: newEnd });
                renderTimeSlots();
            });

            // Render copy-to-days checkboxes
            function renderCopyDaysCheckboxes() {
                const container = document.getElementById('copyDaysCheckboxes');
                if (selectedDay === null) {
                    container.innerHTML = '';
                    return;
                }

                // Show all days except the currently selected one (weekdays only: Mon-Fri = indices 1-5)
                const weekdays = [1, 2, 3, 4, 5]; // Monday to Friday
                container.innerHTML = weekdays
                    .filter(i => i !== selectedDay)
                    .map(i => `
                        <label style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f5; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            <input type="checkbox" class="copy-day-checkbox" value="${i}" style="width: auto; margin: 0;">
                            ${DAYS_SHORT[i]}
                        </label>
                    `).join('');

                // Add change listeners to update copy button state
                container.querySelectorAll('.copy-day-checkbox').forEach(cb => {
                    cb.addEventListener('change', updateCopyButtonState);
                });

                updateCopyButtonState();
            }

            function updateCopyButtonState() {
                const checked = document.querySelectorAll('.copy-day-checkbox:checked').length;
                document.getElementById('copyHoursBtn').disabled = checked === 0 || currentSlots.length === 0;
            }

            // Select all weekdays button
            document.getElementById('selectAllDays').addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.copy-day-checkbox');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);

                checkboxes.forEach(cb => {
                    cb.checked = !allChecked;
                });

                this.textContent = allChecked ? 'Select All Weekdays' : 'Deselect All';
                updateCopyButtonState();
            });

            // Copy hours to selected days
            document.getElementById('copyHoursBtn').addEventListener('click', function() {
                if (selectedDay === null || currentSlots.length === 0) return;

                // Validate current slots first
                for (let i = 0; i < currentSlots.length; i++) {
                    const slot = currentSlots[i];
                    if (slot.start >= slot.end) {
                        showToast(`Slot ${i + 1}: End time must be after start time`, 'error');
                        return;
                    }
                }

                // Sort slots
                const sortedSlots = [...currentSlots].sort((a, b) => a.start.localeCompare(b.start));

                // Check for overlapping
                for (let i = 1; i < sortedSlots.length; i++) {
                    if (sortedSlots[i].start < sortedSlots[i - 1].end) {
                        showToast('Time slots cannot overlap', 'error');
                        return;
                    }
                }

                // Get selected days to copy to
                const selectedDays = Array.from(document.querySelectorAll('.copy-day-checkbox:checked'))
                    .map(cb => parseInt(cb.value));

                if (selectedDays.length === 0) {
                    showToast('Please select days to copy to', 'error');
                    return;
                }

                // Apply to current day first
                availability[selectedDay] = { slots: sortedSlots };

                // Copy to all selected days
                selectedDays.forEach(dayIndex => {
                    availability[dayIndex] = { slots: JSON.parse(JSON.stringify(sortedSlots)) };
                });

                // Uncheck all and update UI
                document.querySelectorAll('.copy-day-checkbox').forEach(cb => cb.checked = false);
                document.getElementById('selectAllDays').textContent = 'Select All Weekdays';
                updateCopyButtonState();

                checkForChanges();
                renderAvailabilityGrid();

                const dayNames = selectedDays.map(i => DAYS_SHORT[i]).join(', ');
                showToast(`Hours copied to ${dayNames}`, 'success');
            });

            function checkForChanges() {
                const hasChanges = JSON.stringify(availability) !== JSON.stringify(originalAvailability);
                document.getElementById('saveAvailability').disabled = !hasChanges;
            }

            // Apply time slots to selected day
            document.getElementById('applyTime').addEventListener('click', function() {
                if (selectedDay === null) return;

                // Validate all slots
                for (let i = 0; i < currentSlots.length; i++) {
                    const slot = currentSlots[i];
                    if (slot.start >= slot.end) {
                        showToast(`Slot ${i + 1}: End time must be after start time`, 'error');
                        return;
                    }
                }

                // Sort slots by start time
                const sortedSlots = [...currentSlots].sort((a, b) => a.start.localeCompare(b.start));

                // Check for overlapping slots
                for (let i = 1; i < sortedSlots.length; i++) {
                    if (sortedSlots[i].start < sortedSlots[i - 1].end) {
                        showToast('Time slots cannot overlap', 'error');
                        return;
                    }
                }

                availability[selectedDay] = { slots: sortedSlots };
                document.getElementById('removeDay').disabled = false;
                checkForChanges();
                renderAvailabilityGrid();

                const slotSummary = sortedSlots.map(s =>
                    `${formatTimeDisplay(s.start)} - ${formatTimeDisplay(s.end)}`
                ).join(', ');
                showToast(`${DAYS[selectedDay]} hours set: ${slotSummary}`, 'success');
            });

            // Remove day from availability
            document.getElementById('removeDay').addEventListener('click', function() {
                if (selectedDay === null) return;

                delete availability[selectedDay];
                currentSlots = [{ start: '09:00', end: '17:00' }];
                renderTimeSlots();
                document.getElementById('removeDay').disabled = true;
                checkForChanges();
                renderAvailabilityGrid();
                showToast(`${DAYS[selectedDay]} removed from schedule`, 'success');
            });

            // Save availability to Firebase
            document.getElementById('saveAvailability').addEventListener('click', async function() {
                const btn = this;
                btn.disabled = true;
                btn.textContent = 'Saving...';

                try {
                    const user = firebase.auth().currentUser;
                    if (!user) {
                        showToast('You must be logged in to save', 'error');
                        return;
                    }

                    await db.collection('availability').doc(user.uid).set({
                        schedule: availability,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    originalAvailability = JSON.parse(JSON.stringify(availability));
                    showToast('Availability saved successfully!', 'success');
                } catch (error) {
                    console.error('Error saving availability:', error);
                    showToast('Failed to save availability', 'error');
                } finally {
                    btn.textContent = 'Save Changes';
                    checkForChanges();
                }
            });

            // Load availability from Firebase
            async function loadAvailability() {
                try {
                    const user = firebase.auth().currentUser;
                    if (!user) return;

                    const doc = await db.collection('availability').doc(user.uid).get();
                    if (doc.exists && doc.data().schedule) {
                        // Migrate old format to new format if needed
                        availability = migrateAvailabilityFormat(doc.data().schedule);
                        originalAvailability = JSON.parse(JSON.stringify(availability));
                    }
                    renderAvailabilityGrid();
                } catch (error) {
                    console.error('Error loading availability:', error);
                }
            }

            // Initialize availability on auth state change
            firebase.auth().onAuthStateChanged(function(user) {
                if (user) {
                    loadAvailability();
                }
            });

            renderAvailabilityGrid();

            // ==================
            // BLOCKED TIMES (Holidays, etc.)
            // ==================
            let blockedTimes = []; // Array of { id, date, startTime, endTime, allDay, reason }
            let blockCalendarMonth = new Date();
            let selectedBlockDates = []; // Array of selected date strings for blocking
            let blockSelectionStart = null; // For range selection

            function formatDateDisplay(dateStr) {
                const date = new Date(dateStr + 'T00:00:00');
                return date.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' });
            }

            function formatDateShort(dateStr) {
                const date = new Date(dateStr + 'T00:00:00');
                return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
            }

            // Render the block calendar
            function renderBlockCalendar() {
                const grid = document.getElementById('blockCalendarGrid');
                const year = blockCalendarMonth.getFullYear();
                const month = blockCalendarMonth.getMonth();

                document.getElementById('blockCalendarMonth').textContent =
                    blockCalendarMonth.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });

                // Monday-Friday headers only
                let html = WEEKDAYS_SHORT.map(d => `<div class="calendar-day-header">${d}</div>`).join('');

                const todayStr = new Date().toISOString().split('T')[0];

                // Find first Monday of display
                let firstMonday = new Date(year, month, 1);
                while (firstMonday.getDay() !== 1) {
                    firstMonday.setDate(firstMonday.getDate() - 1);
                }

                // Generate 6 weeks of weekdays (Mon-Fri)
                let currentDate = new Date(firstMonday);
                for (let week = 0; week < 6; week++) {
                    for (let dayOfWeek = 1; dayOfWeek <= 5; dayOfWeek++) {
                        while (currentDate.getDay() !== dayOfWeek) {
                            currentDate.setDate(currentDate.getDate() + 1);
                        }

                        const dateStr = currentDate.toISOString().split('T')[0];
                        const isCurrentMonth = currentDate.getMonth() === month;
                        const isToday = dateStr === todayStr;
                        const isPast = dateStr < todayStr;
                        const isSelected = selectedBlockDates.includes(dateStr);
                        const isBlocked = blockedTimes.some(b => b.date === dateStr);

                        html += `
                            <div class="calendar-day ${isToday ? 'today' : ''} ${!isCurrentMonth || isPast ? 'other-month' : ''} ${isSelected ? 'selected' : ''} ${isBlocked ? 'blocked' : ''}"
                                 data-date="${dateStr}"
                                 style="${isBlocked ? 'background: #ffebee; border-color: #ef5350;' : ''}">
                                <span class="calendar-date">${currentDate.getDate()}</span>
                                ${isBlocked ? '<span style="font-size: 0.6rem; color: #c62828;">Blocked</span>' : ''}
                            </div>
                        `;

                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    while (currentDate.getDay() !== 1) {
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                }

                grid.innerHTML = html;

                // Add click handlers for calendar days
                grid.querySelectorAll('.calendar-day:not(.other-month)').forEach(dayEl => {
                    dayEl.addEventListener('click', function(e) {
                        const dateStr = this.dataset.date;
                        const todayStr = new Date().toISOString().split('T')[0];
                        if (!dateStr || dateStr < todayStr) return;

                        if (e.shiftKey && blockSelectionStart) {
                            // Range selection with Shift+click
                            const startDate = new Date(blockSelectionStart);
                            const endDate = new Date(dateStr);
                            const [minDate, maxDate] = startDate < endDate ? [startDate, endDate] : [endDate, startDate];

                            selectedBlockDates = [];
                            let d = new Date(minDate);
                            while (d <= maxDate) {
                                const dStr = d.toISOString().split('T')[0];
                                // Only add weekdays and future dates
                                if (d.getDay() >= 1 && d.getDay() <= 5 && dStr >= todayStr) {
                                    selectedBlockDates.push(dStr);
                                }
                                d.setDate(d.getDate() + 1);
                            }
                            blockSelectionStart = null;
                        } else {
                            // Single click - toggle selection or start range
                            const index = selectedBlockDates.indexOf(dateStr);
                            if (index > -1) {
                                selectedBlockDates.splice(index, 1);
                                blockSelectionStart = null;
                            } else {
                                selectedBlockDates.push(dateStr);
                                selectedBlockDates.sort();
                                blockSelectionStart = dateStr;
                            }
                        }

                        updateSelectedBlockDatesDisplay();
                        renderBlockCalendar();
                    });
                });
            }

            // Update selected dates display
            function updateSelectedBlockDatesDisplay() {
                const display = document.getElementById('selectedBlockDatesDisplay');
                const textEl = document.getElementById('selectedBlockDatesText');

                if (selectedBlockDates.length === 0) {
                    display.style.display = 'none';
                    return;
                }

                display.style.display = 'block';

                if (selectedBlockDates.length === 1) {
                    textEl.textContent = formatDateDisplay(selectedBlockDates[0]);
                } else if (selectedBlockDates.length === 2) {
                    textEl.textContent = `${formatDateShort(selectedBlockDates[0])} and ${formatDateShort(selectedBlockDates[1])}`;
                } else {
                    // Check if it's a continuous range
                    const isRange = selectedBlockDates.every((d, i) => {
                        if (i === 0) return true;
                        const prev = new Date(selectedBlockDates[i-1]);
                        const curr = new Date(d);
                        const diffDays = (curr - prev) / (1000 * 60 * 60 * 24);
                        return diffDays <= 3; // Allow weekend gaps
                    });

                    if (isRange) {
                        textEl.textContent = `${formatDateShort(selectedBlockDates[0])} to ${formatDateShort(selectedBlockDates[selectedBlockDates.length - 1])} (${selectedBlockDates.length} days)`;
                    } else {
                        textEl.textContent = `${selectedBlockDates.length} days selected`;
                    }
                }
            }

            // Clear selected dates
            document.getElementById('clearBlockDates').addEventListener('click', function() {
                selectedBlockDates = [];
                blockSelectionStart = null;
                updateSelectedBlockDatesDisplay();
                renderBlockCalendar();
            });

            // Block calendar navigation
            document.getElementById('blockCalPrevMonth').addEventListener('click', function() {
                blockCalendarMonth.setMonth(blockCalendarMonth.getMonth() - 1);
                renderBlockCalendar();
            });

            document.getElementById('blockCalNextMonth').addEventListener('click', function() {
                blockCalendarMonth.setMonth(blockCalendarMonth.getMonth() + 1);
                renderBlockCalendar();
            });

            function renderBlockedTimesList() {
                const container = document.getElementById('blockedTimesList');

                if (blockedTimes.length === 0) {
                    container.innerHTML = '';
                    return;
                }

                // Sort by date
                const sorted = [...blockedTimes].sort((a, b) => a.date.localeCompare(b.date));

                // Group consecutive dates with same time/reason
                const groups = [];
                let currentGroup = null;

                sorted.forEach(block => {
                    if (currentGroup &&
                        currentGroup.allDay === block.allDay &&
                        currentGroup.startTime === block.startTime &&
                        currentGroup.endTime === block.endTime &&
                        currentGroup.reason === block.reason) {
                        // Check if dates are consecutive (allowing weekend gaps)
                        const lastDate = new Date(currentGroup.dates[currentGroup.dates.length - 1]);
                        const thisDate = new Date(block.date);
                        const diffDays = (thisDate - lastDate) / (1000 * 60 * 60 * 24);
                        if (diffDays <= 3) {
                            currentGroup.dates.push(block.date);
                            currentGroup.ids.push(block.id);
                            return;
                        }
                    }
                    currentGroup = {
                        dates: [block.date],
                        ids: [block.id],
                        allDay: block.allDay,
                        startTime: block.startTime,
                        endTime: block.endTime,
                        reason: block.reason
                    };
                    groups.push(currentGroup);
                });

                container.innerHTML = `
                    <h4 style="font-family: 'Montserrat', sans-serif; margin-bottom: 12px; padding-top: 16px; border-top: 1px solid #eee;">Blocked Times</h4>
                    <div class="blocked-times-list">
                        ${groups.map(group => {
                            const dateDisplay = group.dates.length === 1
                                ? formatDateDisplay(group.dates[0])
                                : `${formatDateShort(group.dates[0])} - ${formatDateShort(group.dates[group.dates.length - 1])} (${group.dates.length} days)`;

                            return `
                                <div class="blocked-time-item" data-ids="${group.ids.join(',')}">
                                    <div class="blocked-time-info">
                                        <strong>${dateDisplay}</strong>
                                        <span class="blocked-time-range">
                                            ${group.allDay ? 'All day' : `${formatTimeDisplay(group.startTime)} - ${formatTimeDisplay(group.endTime)}`}
                                        </span>
                                        ${group.reason ? `<span class="blocked-time-reason">${group.reason}</span>` : ''}
                                    </div>
                                    <button class="btn btn-danger btn-sm remove-blocked-time" data-ids="${group.ids.join(',')}">Remove</button>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;

                // Add remove handlers
                container.querySelectorAll('.remove-blocked-time').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const ids = this.dataset.ids.split(',');
                        removeBlockedTimes(ids);
                    });
                });
            }

            // Toggle time inputs based on all-day checkbox
            document.getElementById('blockAllDay').addEventListener('change', function() {
                const disabled = this.checked;
                document.getElementById('blockStartTime').disabled = disabled;
                document.getElementById('blockEndTime').disabled = disabled;
            });

            // Add blocked times for all selected dates
            document.getElementById('addBlockedTime').addEventListener('click', async function() {
                if (selectedBlockDates.length === 0) {
                    showToast('Please select at least one date on the calendar', 'error');
                    return;
                }

                const allDay = document.getElementById('blockAllDay').checked;
                const startTime = document.getElementById('blockStartTime').value;
                const endTime = document.getElementById('blockEndTime').value;
                const reason = document.getElementById('blockReason').value.trim();

                if (!allDay && startTime >= endTime) {
                    showToast('End time must be after start time', 'error');
                    return;
                }

                // Create a block entry for each selected date
                const newBlocks = selectedBlockDates.map(date => ({
                    id: `${Date.now()}_${date}`,
                    date,
                    startTime: allDay ? null : startTime,
                    endTime: allDay ? null : endTime,
                    allDay,
                    reason
                }));

                blockedTimes.push(...newBlocks);
                await saveBlockedTimes();
                renderBlockedTimesList();
                renderBlockCalendar();

                // Build toast message
                let toastMsg;
                if (selectedBlockDates.length === 1) {
                    toastMsg = `Blocked ${formatDateShort(selectedBlockDates[0])}`;
                } else {
                    toastMsg = `Blocked ${selectedBlockDates.length} days`;
                }
                if (reason) toastMsg += ` (${reason})`;

                // Reset form
                selectedBlockDates = [];
                blockSelectionStart = null;
                updateSelectedBlockDatesDisplay();
                document.getElementById('blockAllDay').checked = false;
                document.getElementById('blockStartTime').disabled = false;
                document.getElementById('blockEndTime').disabled = false;
                document.getElementById('blockStartTime').value = '09:00';
                document.getElementById('blockEndTime').value = '17:00';
                document.getElementById('blockReason').value = '';

                showToast(toastMsg, 'success');
            });

            async function removeBlockedTimes(ids) {
                blockedTimes = blockedTimes.filter(b => !ids.includes(b.id));
                await saveBlockedTimes();
                renderBlockedTimesList();
                renderBlockCalendar();
                showToast(`${ids.length > 1 ? ids.length + ' blocked dates' : 'Blocked time'} removed`, 'success');
            }

            async function removeBlockedTime(id) {
                await removeBlockedTimes([id]);
            }

            async function saveBlockedTimes() {
                try {
                    const user = firebase.auth().currentUser;
                    if (!user) return;

                    await db.collection('availability').doc(user.uid).set({
                        blockedTimes: blockedTimes
                    }, { merge: true });
                } catch (error) {
                    console.error('Error saving blocked times:', error);
                    showToast('Failed to save blocked times', 'error');
                }
            }

            async function loadBlockedTimes() {
                try {
                    const user = firebase.auth().currentUser;
                    if (!user) return;

                    const doc = await db.collection('availability').doc(user.uid).get();
                    if (doc.exists && doc.data().blockedTimes) {
                        blockedTimes = doc.data().blockedTimes;
                        renderBlockedTimesList();
                        renderBlockCalendar();
                    }
                } catch (error) {
                    console.error('Error loading blocked times:', error);
                }
            }

            // Update auth listener to also load blocked times
            firebase.auth().onAuthStateChanged(function(user) {
                if (user) {
                    loadBlockedTimes();
                }
            });

            // Initialize block calendar
            renderBlockCalendar();

            // ==================
            // CALENDAR (Monday-Friday only)
            // ==================
            function renderCalendar() {
                const grid = document.getElementById('calendarGrid');
                const year = currentMonth.getFullYear();
                const month = currentMonth.getMonth();

                document.getElementById('calendarMonth').textContent =
                    currentMonth.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });

                // Monday-Friday headers only
                let html = WEEKDAYS_SHORT.map(d => `<div class="calendar-day-header">${d}</div>`).join('');

                const todayStr = new Date().toISOString().split('T')[0];

                // Find first Monday of display (may be in previous month)
                let firstMonday = new Date(year, month, 1);
                while (firstMonday.getDay() !== 1) {
                    firstMonday.setDate(firstMonday.getDate() - 1);
                }

                // Generate 6 weeks of weekdays (Mon-Fri)
                let currentDate = new Date(firstMonday);
                for (let week = 0; week < 6; week++) {
                    for (let dayOfWeek = 1; dayOfWeek <= 5; dayOfWeek++) {
                        while (currentDate.getDay() !== dayOfWeek) {
                            currentDate.setDate(currentDate.getDate() + 1);
                        }

                        const dateStr = currentDate.toISOString().split('T')[0];
                        const isCurrentMonth = currentDate.getMonth() === month;
                        const isToday = dateStr === todayStr;

                        html += `
                            <div class="calendar-day ${isToday ? 'today' : ''} ${!isCurrentMonth ? 'other-month' : ''}" data-date="${dateStr}">
                                <span class="calendar-date">${currentDate.getDate()}</span>
                            </div>
                        `;

                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    while (currentDate.getDay() !== 1) {
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                }

                grid.innerHTML = html;

                grid.querySelectorAll('.calendar-day:not(.other-month)').forEach(day => {
                    day.addEventListener('click', function() {
                        const date = this.dataset.date;
                        if (date) {
                            document.getElementById('selectedDateDisplay').textContent =
                                new Date(date).toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'long' });
                        }
                    });
                });
            }

            document.getElementById('prevMonth').addEventListener('click', () => {
                currentMonth.setMonth(currentMonth.getMonth() - 1);
                renderCalendar();
            });

            document.getElementById('nextMonth').addEventListener('click', () => {
                currentMonth.setMonth(currentMonth.getMonth() + 1);
                renderCalendar();
            });

            renderCalendar();

            // Modal close handlers
            document.getElementById('closeClientModal').addEventListener('click', () => {
                document.getElementById('clientModal').classList.remove('show');
            });
            document.getElementById('cancelClientBtn').addEventListener('click', () => {
                document.getElementById('clientModal').classList.remove('show');
            });
            document.getElementById('closeBookingModal').addEventListener('click', () => {
                document.getElementById('bookingModal').classList.remove('show');
            });
            document.getElementById('cancelBookingBtn').addEventListener('click', () => {
                document.getElementById('bookingModal').classList.remove('show');
            });

            // ==================
            // BOOKING WIZARD FUNCTIONALITY
            // ==================

            // Wizard state
            let wizardState = {
                currentStep: 1,
                clientId: null,
                clientName: null,
                clientBlockEndDate: null,
                duration: 60,
                dates: [], // Array of selected dates for multi-day booking
                times: {}, // Object mapping date -> time for each selected day
                repeatWeekly: false
            };

            let bookingCalendarMonth = new Date();

            // Format time to 12-hour format
            function formatTime12Hour(time24) {
                const [hours, minutes] = time24.split(':').map(Number);
                const period = hours >= 12 ? 'PM' : 'AM';
                const hours12 = hours % 12 || 12;
                return `${hours12}:${minutes.toString().padStart(2, '0')} ${period}`;
            }

            // Reset wizard state
            function resetWizard() {
                wizardState = {
                    currentStep: 1,
                    clientId: null,
                    clientName: null,
                    clientBlockEndDate: null,
                    duration: 60,
                    dates: [],
                    times: {},
                    repeatWeekly: false
                };
                bookingCalendarMonth = new Date();
                document.getElementById('repeatWeekly').checked = false;
                updateWizardUI();
            }

            // Update wizard UI based on current step
            function updateWizardUI() {
                const step = wizardState.currentStep;

                // Update progress steps
                document.querySelectorAll('.wizard-step').forEach((el, i) => {
                    el.classList.remove('active', 'completed');
                    if (i + 1 < step) el.classList.add('completed');
                    if (i + 1 === step) el.classList.add('active');
                });

                // Update panels
                document.querySelectorAll('.wizard-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.querySelector(`.wizard-panel[data-panel="${step}"]`).classList.add('active');

                // Update buttons
                const prevBtn = document.getElementById('prevStepBtn');
                const nextBtn = document.getElementById('nextStepBtn');
                const saveBtn = document.getElementById('saveBookingBtn');

                prevBtn.style.display = step > 1 ? 'inline-flex' : 'none';
                nextBtn.style.display = step < 5 ? 'inline-flex' : 'none';
                saveBtn.style.display = step === 5 ? 'inline-flex' : 'none';

                // Populate step-specific content
                if (step === 1) populateClientSelection();
                if (step === 2) populateDurationSelection();
                if (step === 3) renderBookingCalendar();
                if (step === 4) generatePerDayTimeSelectors();
                if (step === 5) populateSummary();
            }

            // Step 1: Populate client selection
            function populateClientSelection() {
                const grid = document.getElementById('clientSelectionGrid');
                if (clients.length === 0) {
                    grid.innerHTML = '<p style="color: var(--text-muted);">No clients available. Please add a client first.</p>';
                    return;
                }

                grid.innerHTML = clients.map(client => `
                    <div class="client-select-card ${wizardState.clientId === client.id ? 'selected' : ''}"
                         data-id="${client.id}"
                         data-name="${client.name || client.email}"
                         data-duration="${client.blockDuration || 60}"
                         data-blockend="${client.blockEndDate || ''}">
                        <div class="client-select-avatar">${(client.name || 'C')[0].toUpperCase()}</div>
                        <div class="client-select-info">
                            <div class="client-select-name">${client.name || client.email}</div>
                            <div class="client-select-meta">${client.blockDuration || 60} min sessions${client.blockStartDate || client.blockEndDate ? '  ' + (client.blockStartDate ? new Date(client.blockStartDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }) : '') + ' - ' + (client.blockEndDate ? new Date(client.blockEndDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }) : '') : ''}</div>
                        </div>
                    </div>
                `).join('');

                // Add click handlers
                grid.querySelectorAll('.client-select-card').forEach(card => {
                    card.addEventListener('click', function() {
                        grid.querySelectorAll('.client-select-card').forEach(c => c.classList.remove('selected'));
                        this.classList.add('selected');
                        wizardState.clientId = this.dataset.id;
                        wizardState.clientName = this.dataset.name;
                        wizardState.duration = parseInt(this.dataset.duration) || 60;
                        wizardState.clientBlockEndDate = this.dataset.blockend || null;
                        document.getElementById('bookingClient').value = this.dataset.id;
                    });
                });
            }

            // Step 2: Populate duration selection
            function populateDurationSelection() {
                document.querySelectorAll('.duration-option').forEach(btn => {
                    btn.classList.remove('selected');
                    if (parseInt(btn.dataset.duration) === wizardState.duration) {
                        btn.classList.add('selected');
                    }
                });
            }

            // Duration option click handlers
            document.querySelectorAll('.duration-option').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.duration-option').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    wizardState.duration = parseInt(this.dataset.duration);
                    document.getElementById('bookingDuration').value = this.dataset.duration;
                });
            });

            // Step 3: Render booking calendar (Monday-Friday only, multi-select)
            function renderBookingCalendar() {
                const grid = document.getElementById('bookingCalendarGrid');
                const year = bookingCalendarMonth.getFullYear();
                const month = bookingCalendarMonth.getMonth();

                document.getElementById('bookingCalendarMonth').textContent =
                    bookingCalendarMonth.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });

                // Monday-Friday headers only
                let html = WEEKDAYS_SHORT.map(d => `<div class="calendar-day-header">${d}</div>`).join('');

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const todayStr = new Date().toISOString().split('T')[0];

                // Find first Monday of display (may be in previous month)
                let firstMonday = new Date(year, month, 1);
                while (firstMonday.getDay() !== 1) {
                    firstMonday.setDate(firstMonday.getDate() - 1);
                }

                // Generate 6 weeks of weekdays (Mon-Fri)
                let currentDate = new Date(firstMonday);
                for (let week = 0; week < 6; week++) {
                    for (let dayOfWeek = 1; dayOfWeek <= 5; dayOfWeek++) { // Mon=1 to Fri=5
                        // Move to the correct day
                        while (currentDate.getDay() !== dayOfWeek) {
                            currentDate.setDate(currentDate.getDate() + 1);
                        }

                        const dateStr = currentDate.toISOString().split('T')[0];
                        const isCurrentMonth = currentDate.getMonth() === month;
                        const isToday = dateStr === todayStr;
                        const isPast = dateStr < todayStr;
                        const isSelected = wizardState.dates.includes(dateStr);
                        const isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;

                        if (!isWeekend) {
                            html += `
                                <div class="calendar-day ${isToday ? 'today' : ''} ${!isCurrentMonth || isPast ? 'other-month' : ''} ${isSelected ? 'selected' : ''}"
                                     data-date="${dateStr}">
                                    <span class="calendar-date">${currentDate.getDate()}</span>
                                </div>
                            `;
                        }

                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    // Skip weekend to next Monday
                    while (currentDate.getDay() !== 1) {
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                }

                grid.innerHTML = html;

                // Update selected days display
                updateSelectedDaysDisplay();

                // Add click handlers for calendar days (multi-select, max 3)
                grid.querySelectorAll('.calendar-day:not(.other-month)').forEach(dayEl => {
                    dayEl.addEventListener('click', function() {
                        const dateStr = this.dataset.date;
                        if (dateStr && dateStr >= todayStr) {
                            const index = wizardState.dates.indexOf(dateStr);
                            if (index > -1) {
                                // Deselect
                                wizardState.dates.splice(index, 1);
                                this.classList.remove('selected');
                            } else if (wizardState.dates.length < 3) {
                                // Select (max 3)
                                wizardState.dates.push(dateStr);
                                wizardState.dates.sort(); // Keep in order
                                this.classList.add('selected');
                            } else {
                                showToast('You can select up to 3 days', 'warning');
                            }
                            updateSelectedDaysDisplay();
                        }
                    });
                });
            }

            // Update the selected days display
            function updateSelectedDaysDisplay() {
                const display = document.getElementById('selectedDaysDisplay');
                if (wizardState.dates.length === 0) {
                    display.textContent = '';
                } else {
                    const dayNames = wizardState.dates.map(d => {
                        const date = new Date(d);
                        return date.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
                    });
                    display.textContent = `Selected: ${dayNames.join(', ')}`;
                }
            }

            // Booking calendar navigation
            document.getElementById('bookingPrevMonth').addEventListener('click', () => {
                bookingCalendarMonth.setMonth(bookingCalendarMonth.getMonth() - 1);
                renderBookingCalendar();
            });

            document.getElementById('bookingNextMonth').addEventListener('click', () => {
                bookingCalendarMonth.setMonth(bookingCalendarMonth.getMonth() + 1);
                renderBookingCalendar();
            });

            // Step 4: Generate per-day time selectors
            async function generatePerDayTimeSelectors() {
                const container = document.getElementById('perDayTimeSelectors');
                const dates = wizardState.dates;

                if (!dates || dates.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-muted);">Please select at least one day first</p>';
                    return;
                }

                container.innerHTML = '<p style="color: var(--text-muted);">Loading available slots...</p>';

                const duration = wizardState.duration || 60;
                const workingHours = { start: 6, end: 21 };

                // Get existing bookings for all selected dates
                let allExistingBookings = {};
                for (const dateStr of dates) {
                    try {
                        const snapshot = await db.collection('bookings')
                            .where('date', '==', dateStr)
                            .where('status', '==', 'confirmed')
                            .get();
                        allExistingBookings[dateStr] = snapshot.docs.map(doc => doc.data());
                    } catch (error) {
                        try {
                            const snapshot = await db.collection('bookings')
                                .where('date', '==', dateStr)
                                .get();
                            allExistingBookings[dateStr] = snapshot.docs.map(doc => doc.data()).filter(b => b.status !== 'cancelled');
                        } catch (err) {
                            allExistingBookings[dateStr] = [];
                        }
                    }
                }

                // Get today's date string for comparison
                const todayStr = new Date().toISOString().split('T')[0];

                // Generate slots for each day
                let html = '';
                for (const dateStr of dates) {
                    const date = new Date(dateStr + 'T00:00:00');
                    const dayOfWeek = date.getDay(); // 0=Sunday, 1=Monday, etc.
                    const dayName = date.toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'short' });
                    const existingBookings = allExistingBookings[dateStr] || [];

                    // Get trainer's availability for this day of week
                    const daySlots = getDaySlots(dayOfWeek);

                    // Check if this date is today and calculate min allowed time
                    const isToday = dateStr === todayStr;
                    let minAllowedMinutes = 0;
                    if (isToday) {
                        const now = new Date();
                        const currentMinutes = now.getHours() * 60 + now.getMinutes();
                        // Round up to the next 15-minute slot + 15 min buffer
                        minAllowedMinutes = Math.ceil((currentMinutes + 15) / 15) * 15;
                    }

                    // Generate available slots only within trainer's availability windows
                    const slots = [];

                    if (daySlots && daySlots.length > 0) {
                        daySlots.forEach(availSlot => {
                            const [startHour, startMin] = availSlot.start.split(':').map(Number);
                            const [endHour, endMin] = availSlot.end.split(':').map(Number);
                            const availStartMinutes = startHour * 60 + startMin;
                            const availEndMinutes = endHour * 60 + endMin;

                            // Generate 15-minute increment slots within this availability window
                            for (let slotStartMinutes = availStartMinutes; slotStartMinutes + duration <= availEndMinutes; slotStartMinutes += 15) {
                                const hour = Math.floor(slotStartMinutes / 60);
                                const minute = slotStartMinutes % 60;
                                const slotStart = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                                const slotEndMinutes = slotStartMinutes + duration;

                                // Check if this time has already passed today
                                const isPastTime = isToday && slotStartMinutes < minAllowedMinutes;

                                const isBooked = existingBookings.some(booking => {
                                    const [bHour, bMin] = booking.time.split(':').map(Number);
                                    const bookingStart = bHour * 60 + bMin;
                                    const bookingDuration = parseInt(booking.duration) || 60;
                                    const bookingEnd = bookingStart + bookingDuration;
                                    return (slotStartMinutes < bookingEnd && slotEndMinutes > bookingStart);
                                });

                                slots.push({ time: slotStart, isBooked: isBooked || isPastTime, isPastTime });
                            }
                        });
                    }

                    const selectedTime = wizardState.times[dateStr] || '';

                    html += `
                        <div class="day-time-selector" data-date="${dateStr}">
                            <div class="day-time-header">
                                <span class="day-time-label">${dayName}</span>
                                <span class="day-time-selected" id="selectedTime_${dateStr}">${selectedTime ? formatTime12Hour(selectedTime) : 'Select time'}</span>
                            </div>
                            <div class="time-slots-container day-slots" id="slots_${dateStr}">
                                ${slots.length === 0 ?
                                    '<p style="color: var(--text-muted); text-align: center; padding: 12px; margin: 0;">No availability set for this day</p>' :
                                    slots.map(slot => `
                                        <button type="button" class="time-slot ${slot.isBooked ? 'booked' : ''} ${slot.isPastTime ? 'past-time' : ''} ${selectedTime === slot.time ? 'selected' : ''}"
                                                data-time="${slot.time}"
                                                data-date="${dateStr}"
                                                ${slot.isBooked ? 'disabled' : ''}
                                                ${slot.isPastTime ? 'title="This time has already passed"' : (slot.isBooked ? 'title="This time is already booked"' : '')}>
                                            ${formatTime12Hour(slot.time)}
                                        </button>
                                    `).join('')
                                }
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html;

                // Add click handlers
                container.querySelectorAll('.time-slot:not(.booked)').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const dateStr = this.dataset.date;
                        const time = this.dataset.time;

                        // Deselect others for this day
                        document.querySelectorAll(`#slots_${dateStr} .time-slot`).forEach(b => b.classList.remove('selected'));
                        this.classList.add('selected');

                        // Update state
                        wizardState.times[dateStr] = time;

                        // Update display
                        document.getElementById(`selectedTime_${dateStr}`).textContent = formatTime12Hour(time);
                    });
                });
            }

            // Step 5: Populate summary
            function populateSummary() {
                document.getElementById('summaryClient').textContent = wizardState.clientName || '-';
                document.getElementById('summaryDuration').textContent = wizardState.duration + ' minutes';

                // Show sessions per week
                if (wizardState.dates && wizardState.dates.length > 0) {
                    document.getElementById('summarySessionsPerWeek').textContent = wizardState.dates.length;
                    document.getElementById('sessionsPerWeekItem').style.display = 'flex';

                    // Show each day with its time
                    const scheduleHtml = wizardState.dates.map(dateStr => {
                        const date = new Date(dateStr);
                        const dayName = date.toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'short' });
                        const time = wizardState.times[dateStr];
                        return `
                            <div class="summary-item">
                                <span class="summary-label">${dayName}</span>
                                <span class="summary-value">${time ? formatTime12Hour(time) : '-'}</span>
                            </div>
                        `;
                    }).join('');
                    document.getElementById('summarySchedule').innerHTML = scheduleHtml;
                } else {
                    document.getElementById('sessionsPerWeekItem').style.display = 'none';
                    document.getElementById('summarySchedule').innerHTML = '';
                }

                // Update repeat info
                updateRepeatInfo();
            }

            // Calculate repeat weekly sessions (now supports multiple days per week)
            function updateRepeatInfo() {
                const repeatCheckbox = document.getElementById('repeatWeekly');
                const repeatInfo = document.getElementById('repeatInfo');

                if (!wizardState.clientBlockEndDate || !wizardState.dates || wizardState.dates.length === 0) {
                    repeatInfo.style.display = 'none';
                    repeatCheckbox.parentElement.style.display = 'none';
                    return;
                }

                repeatCheckbox.parentElement.style.display = 'flex';

                if (repeatCheckbox.checked) {
                    const endDate = new Date(wizardState.clientBlockEndDate);
                    const sessionsPerWeek = wizardState.dates.length;
                    let totalSessions = 0;

                    // Count sessions for each selected day until block end
                    for (const dateStr of wizardState.dates) {
                        const startDate = new Date(dateStr);
                        let currentDate = new Date(startDate);

                        while (currentDate <= endDate) {
                            totalSessions++;
                            currentDate.setDate(currentDate.getDate() + 7);
                        }
                    }

                    document.getElementById('repeatCount').textContent = totalSessions;
                    document.getElementById('repeatSessionsPerWeek').textContent = sessionsPerWeek;
                    document.getElementById('repeatEndDate').textContent = endDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
                    repeatInfo.style.display = 'block';
                    wizardState.repeatWeekly = true;
                } else {
                    repeatInfo.style.display = 'none';
                    wizardState.repeatWeekly = false;
                }
            }

            // Repeat weekly checkbox handler
            document.getElementById('repeatWeekly').addEventListener('change', updateRepeatInfo);

            // Open booking modal
            document.getElementById('addBookingBtn').addEventListener('click', () => {
                resetWizard();
                document.getElementById('bookingModal').classList.add('show');
            });

            // Navigation buttons
            document.getElementById('nextStepBtn').addEventListener('click', () => {
                // Validate current step
                if (wizardState.currentStep === 1 && !wizardState.clientId) {
                    showToast('Please select a client', 'error');
                    return;
                }
                if (wizardState.currentStep === 3 && (!wizardState.dates || wizardState.dates.length === 0)) {
                    showToast('Please select at least one day', 'error');
                    return;
                }
                if (wizardState.currentStep === 4) {
                    // Check all selected days have times
                    const missingTimes = wizardState.dates.filter(d => !wizardState.times[d]);
                    if (missingTimes.length > 0) {
                        const missingDays = missingTimes.map(d => new Date(d).toLocaleDateString('en-GB', { weekday: 'short' }));
                        showToast(`Please select a time for: ${missingDays.join(', ')}`, 'error');
                        return;
                    }
                }

                if (wizardState.currentStep < 5) {
                    wizardState.currentStep++;
                    updateWizardUI();
                }
            });

            document.getElementById('prevStepBtn').addEventListener('click', () => {
                if (wizardState.currentStep > 1) {
                    wizardState.currentStep--;
                    updateWizardUI();
                }
            });

            // Save booking(s)
            document.getElementById('saveBookingBtn').addEventListener('click', async () => {
                const clientId = wizardState.clientId;
                const selectedDates = wizardState.dates;
                const duration = wizardState.duration;
                const times = wizardState.times; // Per-day times
                const notes = document.getElementById('bookingNotes').value.trim();
                const repeatWeekly = wizardState.repeatWeekly;

                // Validate all days have times selected
                const missingTimes = selectedDates.filter(d => !times[d]);
                if (!clientId || !selectedDates || selectedDates.length === 0 || missingTimes.length > 0) {
                    showToast('Missing required booking information', 'error');
                    return;
                }

                const saveBtn = document.getElementById('saveBookingBtn');
                saveBtn.disabled = true;
                saveBtn.textContent = 'Creating...';

                try {
                    const client = clients.find(c => c.id === clientId);
                    const bookingsToCreate = [];
                    const recurringGroupId = Date.now().toString(); // Unique ID for this recurring group

                    if (repeatWeekly && wizardState.clientBlockEndDate) {
                        // Create recurring bookings for ALL selected days
                        const endDate = new Date(wizardState.clientBlockEndDate);

                        for (const dateStr of selectedDates) {
                            const startDate = new Date(dateStr);
                            const timeForThisDay = times[dateStr]; // Use the specific time for this day
                            let currentDate = new Date(startDate);

                            while (currentDate <= endDate) {
                                bookingsToCreate.push({
                                    clientId: clientId,
                                    clientName: client ? client.name : 'Unknown',
                                    clientEmail: client ? client.email : '',
                                    date: currentDate.toISOString().split('T')[0],
                                    time: timeForThisDay,
                                    duration: duration,
                                    notes: notes,
                                    status: 'confirmed',
                                    isRecurring: true,
                                    recurringGroupId: recurringGroupId,
                                    recurringGroupDate: dateStr, // Original start date for this day
                                    sessionsPerWeek: selectedDates.length,
                                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                    createdBy: auth.currentUser.uid
                                });
                                currentDate.setDate(currentDate.getDate() + 7);
                            }
                        }
                    } else {
                        // Create bookings for selected days only (no repeat)
                        for (const dateStr of selectedDates) {
                            bookingsToCreate.push({
                                clientId: clientId,
                                clientName: client ? client.name : 'Unknown',
                                clientEmail: client ? client.email : '',
                                date: dateStr,
                                time: times[dateStr], // Use the specific time for this day
                                duration: duration,
                                notes: notes,
                                status: 'confirmed',
                                isRecurring: false,
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                createdBy: auth.currentUser.uid
                            });
                        }
                    }

                    // Check for conflicts before creating
                    const conflictingDates = [];
                    for (const booking of bookingsToCreate) {
                        const snapshot = await db.collection('bookings')
                            .where('date', '==', booking.date)
                            .get();

                        const existingBookings = snapshot.docs.map(doc => doc.data()).filter(b => b.status !== 'cancelled');
                        const bookingStartMinutes = parseInt(booking.time.split(':')[0]) * 60 + parseInt(booking.time.split(':')[1]);
                        const bookingEndMinutes = bookingStartMinutes + booking.duration;

                        const hasConflict = existingBookings.some(existing => {
                            const [eHour, eMin] = existing.time.split(':').map(Number);
                            const existingStart = eHour * 60 + eMin;
                            const existingDuration = parseInt(existing.duration) || 60;
                            const existingEnd = existingStart + existingDuration;
                            return (bookingStartMinutes < existingEnd && bookingEndMinutes > existingStart);
                        });

                        if (hasConflict) {
                            conflictingDates.push(booking.date);
                        }
                    }

                    if (conflictingDates.length > 0) {
                        const skipConflicts = confirm(`There are booking conflicts on: ${conflictingDates.slice(0, 3).join(', ')}${conflictingDates.length > 3 ? ` and ${conflictingDates.length - 3} more` : ''}.\n\nDo you want to skip these dates and create the remaining bookings?`);
                        if (!skipConflicts) {
                            saveBtn.disabled = false;
                            saveBtn.textContent = 'Create Booking';
                            return;
                        }
                    }

                    // Create bookings (skip conflicting dates)
                    let createdCount = 0;
                    for (const booking of bookingsToCreate) {
                        if (!conflictingDates.includes(booking.date)) {
                            await db.collection('bookings').add(booking);
                            createdCount++;
                        }
                    }

                    if (createdCount > 1) {
                        showToast(`${createdCount} weekly bookings created successfully!`);
                    } else if (createdCount === 1) {
                        showToast('Booking created successfully!');
                    } else {
                        showToast('No bookings were created due to conflicts', 'warning');
                    }

                    document.getElementById('bookingModal').classList.remove('show');
                    updateStats();
                    loadTodayBookings();
                } catch (error) {
                    console.error('Error creating booking:', error);
                    showToast('Failed to create booking: ' + error.message, 'error');
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Create Booking';
                }
            });

            // Load today's bookings for dashboard
            async function loadTodayBookings() {
                const container = document.getElementById('todayBookings');
                const todayStr = new Date().toISOString().split('T')[0];

                try {
                    const snapshot = await db.collection('bookings')
                        .where('date', '==', todayStr)
                        .orderBy('time')
                        .get();

                    if (snapshot.empty) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                                <h4>No sessions scheduled</h4>
                                <p>Your day is free!</p>
                            </div>
                        `;
                        return;
                    }

                    container.innerHTML = snapshot.docs.map(doc => {
                        const booking = doc.data();
                        return `
                            <div class="booking-item">
                                <div class="booking-time">${formatTime12Hour(booking.time)}</div>
                                <div class="booking-info">
                                    <div class="booking-client">${booking.clientName || 'Unknown Client'}</div>
                                    <div class="booking-duration">${booking.duration} minutes</div>
                                </div>
                                <div class="booking-status ${booking.status}">${booking.status}</div>
                            </div>
                        `;
                    }).join('');
                } catch (error) {
                    console.error('Error loading today\'s bookings:', error);
                    // Try without orderBy if index doesn't exist
                    try {
                        const snapshot = await db.collection('bookings')
                            .where('date', '==', todayStr)
                            .get();

                        if (snapshot.empty) {
                            container.innerHTML = `
                                <div class="empty-state">
                                    <h4>No sessions scheduled</h4>
                                    <p>Your day is free!</p>
                                </div>
                            `;
                            return;
                        }

                        const bookings = snapshot.docs.map(doc => doc.data()).sort((a, b) => a.time.localeCompare(b.time));

                        container.innerHTML = bookings.map(booking => `
                            <div class="booking-item">
                                <div class="booking-time">${formatTime12Hour(booking.time)}</div>
                                <div class="booking-info">
                                    <div class="booking-client">${booking.clientName || 'Unknown Client'}</div>
                                    <div class="booking-duration">${booking.duration} minutes</div>
                                </div>
                                <div class="booking-status ${booking.status}">${booking.status}</div>
                            </div>
                        `).join('');
                    } catch (err) {
                        console.error('Error loading bookings (fallback):', err);
                    }
                }
            }

            // Load today's bookings on page load
            loadTodayBookings();

            // Load bookings for selected day in calendar
            async function loadSelectedDayBookings(dateStr) {
                const container = document.getElementById('selectedDayBookings');
                container.innerHTML = '<p style="color: var(--text-muted);">Loading...</p>';

                try {
                    const snapshot = await db.collection('bookings')
                        .where('date', '==', dateStr)
                        .get();

                    if (snapshot.empty) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <p>No bookings for this day</p>
                            </div>
                        `;
                        return;
                    }

                    const bookings = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => a.time.localeCompare(b.time));

                    container.innerHTML = bookings.map(booking => `
                        <div class="booking-item">
                            <div class="booking-time">${formatTime12Hour(booking.time)}</div>
                            <div class="booking-info">
                                <div class="booking-client">${booking.clientName || 'Unknown Client'}</div>
                                <div class="booking-duration">${booking.duration} minutes</div>
                            </div>
                            <div class="booking-actions">
                                <button class="btn btn-sm btn-danger" onclick="cancelBooking('${booking.id}', '${dateStr}')">Cancel</button>
                            </div>
                        </div>
                    `).join('');
                } catch (error) {
                    console.error('Error loading bookings:', error);
                    container.innerHTML = '<p style="color: var(--danger);">Error loading bookings</p>';
                }
            }

            // Cancel booking function (global)
            window.cancelBooking = async (bookingId, dateStr) => {
                if (!confirm('Are you sure you want to cancel this booking?')) return;

                try {
                    await db.collection('bookings').doc(bookingId).delete();
                    showToast('Booking cancelled');
                    loadSelectedDayBookings(dateStr);
                    updateStats();
                    loadTodayBookings();
                } catch (error) {
                    console.error('Error cancelling booking:', error);
                    showToast('Failed to cancel booking', 'error');
                }
            };

            // Update calendar day click to load bookings
            const originalRenderCalendar = renderCalendar;
            renderCalendar = function() {
                originalRenderCalendar();
                document.querySelectorAll('#calendarGrid .calendar-day:not(.other-month)').forEach(day => {
                    day.addEventListener('click', function() {
                        const date = this.dataset.date;
                        if (date) {
                            // Update selected state
                            document.querySelectorAll('#calendarGrid .calendar-day').forEach(d => d.classList.remove('selected'));
                            this.classList.add('selected');

                            // Update display and load bookings
                            document.getElementById('selectedDateDisplay').textContent =
                                new Date(date).toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'long' });
                            loadSelectedDayBookings(date);
                        }
                    });
                });
            };
            // Re-render to apply new click handlers
            renderCalendar();
        });
    </script>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('../sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed:', err);
                    });
            });
        }
    </script>
</body>
</html>
